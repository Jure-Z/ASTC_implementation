const BLOCK_MAX_TEXELS : u32 = 144;
const WORKGROUP_SIZE: u32 = 256u;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> inputBlocks: array<InputBlock>;
@group(0) @binding(2) var<storage, read_write> cluster_centers: array<vec4<f32>>;


var<workgroup> pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>;
var<workgroup> distances: array<f32, BLOCK_MAX_TEXELS>;
var<workgroup> centers: array<vec4<f32>, 4>;

var<workgroup> s_reduction_value: atomic<u32>;
var<workgroup> s_reduction_index: atomic<u32>;


fn dist_sq(c1: vec4<f32>, c2: vec4<f32>) -> f32 {
    let diff = c1 - c2;
    let diff2 = diff * diff;
    return dot(diff2, uniforms.channel_weights);
}


@compute @workgroup_size(WORKGROUP_SIZE)
fn main( @builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {

    let block_idx = group_id.x;

    if (local_idx < uniforms.texel_count) {
        pixels[local_idx] = inputBlocks[block_idx].pixels[local_idx];
    }
    workgroupBarrier();

    //pick random center for first cluster
    if (local_idx == 0) {
        let sample_index = 145897 % uniforms.texel_count;
        centers[0] = pixels[sample_index];
    }
    workgroupBarrier();

    //compute distances to first center
    if (local_idx < uniforms.texel_count) {
        distances[local_idx] = dist_sq(centers[0], pixels[local_idx]);
    }
    workgroupBarrier();


    //find the remaining centers
    for(var p = 1u; p < uniforms.partition_count; p += 1u) {
        
        //find the farthest point from any center
        if(local_idx == 0) {
            atomicStore(&s_reduction_value, 0u);
            atomicStore(&s_reduction_index, 0u);
        }
        workgroupBarrier();

        //find max distance
        if(local_idx < uniforms.texel_count) {
            atomicMax(&s_reduction_value, bitcast<u32>(distances[local_idx]));
        }
        workgroupBarrier();

        //each thread compares its distance to the max
        if (local_idx < uniforms.texel_count) {
            let max_dist_u32 = atomicLoad(&s_reduction_value);
            if(bitcast<u32>(distances[local_idx]) == max_dist_u32) {
                atomicStore(&s_reduction_index, local_idx);
            }
        }
        workgroupBarrier();

        //thread 0 stores the new center
        if(local_idx == 0) {
			let new_center_index = atomicLoad(&s_reduction_index);
			centers[p] = pixels[new_center_index];
		}
        workgroupBarrier();

        //update distances
        if(p < uniforms.partition_count - 1u) {
            if (local_idx < uniforms.texel_count) {
                let new_dist = dist_sq(centers[p], pixels[local_idx]);
                distances[local_idx] = min(distances[local_idx], new_dist);
            }
            workgroupBarrier();
        }
    }

    //write out the centers
    if(local_idx < uniforms.partition_count) {
        let out_idx = block_idx * 4u + local_idx;
        cluster_centers[out_idx] = centers[local_idx];
    }

}const BLOCK_MAX_TEXELS: u32 = 144u;
const WORKGROUP_SIZE: u32 = 256u;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> inputBlocks: array<InputBlock>;
@group(0) @binding(2) var<storage, read> cluster_centers: array<vec4<f32>>;

@group(0) @binding(3) var<storage, read_write> texel_assignments : array<u32>;


fn dist_sq(c1: vec4f, c2: vec4f) -> f32 {
    let diff = c1 - c2;
    let diff2 = diff * diff;
    return dot(diff2, uniforms.channel_weights);
}


var<workgroup> centers: array<vec4f, 4>;

var<workgroup> partition_counts: array<atomic<u32>, 4>;
var<workgroup> is_problematic: atomic<u32>;


@compute @workgroup_size(WORKGROUP_SIZE)
fn main( @builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {

    let block_idx = group_id.x;

    //copy cluster centers to local memory
    if(local_idx < uniforms.partition_count) {
        centers[local_idx] = cluster_centers[block_idx * 4u + local_idx];
        atomicStore(&partition_counts[local_idx], 0u);
    }
    workgroupBarrier();


    //find colosest center for every texel
    if(local_idx < uniforms.texel_count) {
        let pixel = inputBlocks[block_idx].pixels[local_idx];

        var best_dist = 1e30; // Initialize with a very large number
        var best_partition_idx = 0u;

        for (var p = 0u; p < uniforms.partition_count; p = p + 1u) {
		    let center = centers[p];
		    let d = dist_sq(pixel, center);
		    if (d < best_dist) {
			    best_dist = d;
			    best_partition_idx = p;
		    }
	    }

        let out_idx = block_idx * BLOCK_MAX_TEXELS + local_idx;
        texel_assignments[out_idx] = best_partition_idx;
        atomicAdd(&partition_counts[best_partition_idx], 1u);
    }
    workgroupBarrier();


    if (local_idx == 0) {
        atomicStore(&is_problematic, 0u);
    }
    workgroupBarrier();

    //check final counts
    if (local_idx < uniforms.partition_count) {
        if (atomicLoad(&partition_counts[local_idx]) == 0u) {
            // If a partition is empty, set the shared flag.
            atomicStore(&is_problematic, 1u);
        }
    }
    workgroupBarrier();

    //if any of the clusters were empty, forcibly reasign texels
    let problem_found = (atomicLoad(&is_problematic) == 1u);
    if (problem_found) {
        if (local_idx < uniforms.partition_count) {
            let out_idx = block_idx * BLOCK_MAX_TEXELS + local_idx;
            texel_assignments[out_idx] = local_idx;
        }
    }
}const BLOCK_MAX_TEXELS: u32 = 144u;
const WORKGROUP_SIZE: u32 = 256u;


struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> inputBlocks: array<InputBlock>;
@group(0) @binding(2) var<storage, read> texel_assignments : array<u32>;

@group(0) @binding(3) var<storage, read_write> cluster_centers: array<vec4<f32>>;


var<workgroup> partition_sums: array<array<atomic<u32>, 4>, 4>;
var<workgroup> partition_counts: array<atomic<u32>, 4>;


@compute @workgroup_size(WORKGROUP_SIZE)
fn main( @builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {
    
    let block_idx = group_id.x;

    //init atomic variables to zero
    if (local_idx < uniforms.partition_count) {
        atomicStore(&partition_counts[local_idx], 0u);
        atomicStore(&partition_sums[local_idx][0], 0u); // R
        atomicStore(&partition_sums[local_idx][1], 0u); // G
        atomicStore(&partition_sums[local_idx][2], 0u); // B
        atomicStore(&partition_sums[local_idx][3], 0u); // A
    }
    workgroupBarrier();

    // accumulate partition sums and counts
    if (local_idx < uniforms.texel_count) {
        let global_idx = block_idx * BLOCK_MAX_TEXELS + local_idx;
        let p = texel_assignments[global_idx];
        let pixel = inputBlocks[block_idx].pixels[local_idx];
        
        // Convert f32 color to u32 fixed-point for atomic operations.
        let pixel_u32 = vec4<u32>(pixel);

        // Add to the appropriate partition's sum and count.
        atomicAdd(&partition_sums[p][0], pixel_u32.r);
        atomicAdd(&partition_sums[p][1], pixel_u32.g);
        atomicAdd(&partition_sums[p][2], pixel_u32.b);
        atomicAdd(&partition_sums[p][3], pixel_u32.a);
        atomicAdd(&partition_counts[p], 1u);
    }
    workgroupBarrier();


    // Compute final cluster centers
    if (local_idx < uniforms.partition_count) {

        let p = local_idx;
        let count = atomicLoad(&partition_counts[p]);

        var new_center = vec4<f32>(0.0);

        if(count > 0u) {
            let sum_r = f32(atomicLoad(&partition_sums[p][0]));
            let sum_g = f32(atomicLoad(&partition_sums[p][1]));
            let sum_b = f32(atomicLoad(&partition_sums[p][2]));
            let sum_a = f32(atomicLoad(&partition_sums[p][3]));

            let f_count = f32(count);

            new_center = vec4f(
                sum_r / f_count,
                sum_g / f_count,
                sum_b / f_count,
                sum_a / f_count
            );
        }

        cluster_centers[block_idx * 4u + p] = new_center;
        
    }
}const BLOCK_MAX_TEXELS: u32 = 144u;
const KMEANS_TEXELS: u32 = 64u;
const WORKGROUP_SIZE: u32 = 256u;
const BLOCK_MAX_PARTITIONINGS: u32 = 1024u;


struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};



@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> kmeans_texels : array<u32, KMEANS_TEXELS>;
@group(0) @binding(2) var<storage, read> coverage_bitmaps_2 : array<vec2<u32>, 2 * BLOCK_MAX_PARTITIONINGS>;
@group(0) @binding(3) var<storage, read> coverage_bitmaps_3 : array<vec2<u32>, 3 * BLOCK_MAX_PARTITIONINGS>;
@group(0) @binding(4) var<storage, read> coverage_bitmaps_4 : array<vec2<u32>, 4 * BLOCK_MAX_PARTITIONINGS>;
@group(0) @binding(5) var<storage, read> texel_assignments : array<u32>;

@group(0) @binding(6) var<storage, read_write> mismatch_counts : array<u32>;


//split into two arrays, since atomic doesn't work vith vec2
var<workgroup> kmeans_bitmasks_high: array<atomic<u32>, 4>;
var<workgroup> kmeans_bitmasks_low: array<atomic<u32>, 4>;


fn popcount(v_in: u32) -> u32 {
    let mask1 = 0x55555555u;
    let mask2 = 0x33333333u;
    let mask3 = 0x0F0F0F0Fu;
    var v = v_in;

    v -= (v >> 1u) & mask1;
    v = (v & mask2) + ((v >> 2u) & mask2);
    v = (v + (v >> 4u)) & mask3;
    v *= 0x01010101u;
    v = v >> 24u;
    return v;
}

fn popcount64(v: vec2<u32>) -> u32 {
    return popcount(v.x) + popcount(v.y);
}

fn xor64(a: vec2<u32>, b: vec2<u32>) -> vec2<u32> {
	return vec2<u32>(a.x ^ b.x, a.y ^ b.y);
}

@compute @workgroup_size(WORKGROUP_SIZE)
fn main( @builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {
    
    let block_idx = group_id.x;

    //build k-means bitmasks
    if (local_idx < uniforms.partition_count) {
        atomicStore(&kmeans_bitmasks_high[local_idx], 0u);
        atomicStore(&kmeans_bitmasks_low[local_idx], 0u);
    }
    workgroupBarrier();
    if(local_idx < KMEANS_TEXELS) {
        let texel_idx = kmeans_texels[local_idx];
        let global_idx = block_idx * BLOCK_MAX_TEXELS + texel_idx;
        let partition_assignment = texel_assignments[global_idx];
        let bit_to_set = 1u << (local_idx % 32u);
        if(local_idx < 32u) {
            atomicOr(&kmeans_bitmasks_low[partition_assignment], bit_to_set);
		} else {
			atomicOr(&kmeans_bitmasks_high[partition_assignment], bit_to_set);
		}
    }
    workgroupBarrier();


    let partition_count = uniforms.partition_count;
    let partitioning_count_selected = uniforms.partitioning_count_selected[partition_count - 1u];

    for(var i = local_idx; i < partitioning_count_selected; i += WORKGROUP_SIZE) {
        
        var mismatch_count = 0u;
        
        let a0 = vec2<u32>(atomicLoad(&kmeans_bitmasks_low[0]), atomicLoad(&kmeans_bitmasks_high[0]));
        let a1 = vec2<u32>(atomicLoad(&kmeans_bitmasks_low[1]), atomicLoad(&kmeans_bitmasks_high[1]));
        let a2 = vec2<u32>(atomicLoad(&kmeans_bitmasks_low[2]), atomicLoad(&kmeans_bitmasks_high[2]));
        let a3 = vec2<u32>(atomicLoad(&kmeans_bitmasks_low[3]), atomicLoad(&kmeans_bitmasks_high[3]));

        if(uniforms.partition_count == 2u) {
            let b0 = coverage_bitmaps_2[2 * i + 0];
            let b1 = coverage_bitmaps_2[2 * i + 1];

            let v1 = popcount64(xor64(a0, b0)) + popcount64(xor64(a1, b1));
            let v2 = popcount64(xor64(a0, b1)) + popcount64(xor64(a1, b0));

            mismatch_count = min(v1, v2) / 2u;
        }
        else if(uniforms.partition_count == 3u) {
            let b0 = coverage_bitmaps_3[3 * i + 0];
			let b1 = coverage_bitmaps_3[3 * i + 1];
			let b2 = coverage_bitmaps_3[3 * i + 2];

			let p00 = popcount64(xor64(a0, b0));
            let p01 = popcount64(xor64(a0, b1));
            let p02 = popcount64(xor64(a0, b2));
            let p10 = popcount64(xor64(a1, b0));
            let p11 = popcount64(xor64(a1, b1));
            let p12 = popcount64(xor64(a1, b2));
            let p20 = popcount64(xor64(a2, b0));
            let p21 = popcount64(xor64(a2, b1));
            let p22 = popcount64(xor64(a2, b2));

            let s0 = p11 + p22;
            let s1 = p12 + p21;
            let v0 = min(s0, s1) + p00;

            let s2 = p10 + p22;
            let s3 = p12 + p20;
            let v1 = min(s2, s3) + p01;

            let s4 = p10 + p21;
            let s5 = p11 + p20;
            let v2 = min(s4, s5) + p02;

            mismatch_count = min(v0, min(v1, v2)) / 2u;
		}
		else if(uniforms.partition_count == 4u) {
			let b0 = coverage_bitmaps_4[4 * i + 0];
			let b1 = coverage_bitmaps_4[4 * i + 1];
			let b2 = coverage_bitmaps_4[4 * i + 2];
			let b3 = coverage_bitmaps_4[4 * i + 3];

			let p00 = popcount64(xor64(a0, b0));
			let p01 = popcount64(xor64(a0, b1));
			let p02 = popcount64(xor64(a0, b2));
			let p03 = popcount64(xor64(a0, b3));
			let p10 = popcount64(xor64(a1, b0));
			let p11 = popcount64(xor64(a1, b1));
			let p12 = popcount64(xor64(a1, b2));
			let p13 = popcount64(xor64(a1, b3));
			let p20 = popcount64(xor64(a2, b0));
			let p21 = popcount64(xor64(a2, b1));
			let p22 = popcount64(xor64(a2, b2));
			let p23 = popcount64(xor64(a2, b3));
			let p30 = popcount64(xor64(a3, b0));
			let p31 = popcount64(xor64(a3, b1));
			let p32 = popcount64(xor64(a3, b2));
			let p33 = popcount64(xor64(a3, b3));

			let mx23 = min(p22 + p33, p23 + p32);
            let mx13 = min(p21 + p33, p23 + p31);
            let mx12 = min(p21 + p32, p22 + p31);
            let mx03 = min(p20 + p33, p23 + p30);
            let mx02 = min(p20 + p32, p22 + p30);
            let mx01 = min(p21 + p30, p20 + p31);

            let v0 = p00 + min(p11 + mx23, min(p12 + mx13, p13 + mx12));
            let v1 = p01 + min(p10 + mx23, min(p12 + mx03, p13 + mx02));
            let v2 = p02 + min(p11 + mx03, min(p10 + mx13, p13 + mx01));
            let v3 = p03 + min(p11 + mx02, min(p12 + mx01, p10 + mx12));

            mismatch_count = min(v0, min(v1, min(v2, v3))) / 2u;
        }

        let out_idx = block_idx * BLOCK_MAX_PARTITIONINGS * i;
        mismatch_counts[out_idx] = mismatch_count;
    }
}const BLOCK_MAX_PARTITIONINGS: u32 = 1024u;
const SORT_ITEM_COUNT: u32 = BLOCK_MAX_PARTITIONINGS;
const WORKGROUP_SIZE: u32 = 256u;
const MAX_PARTITIONING_CANDIDATE_LIMIT: u32 = 512u;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    tune_partitoning_candidate_limit: u32,
    _padding1: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct sortElement {
	score : u32,
	index : u32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> mismatch_counts : array<u32>;

@group(0) @binding(2) var<storage, read_write> partition_ordering : array<u32>;


var<workgroup> s_data: array<sortElement, SORT_ITEM_COUNT>;

@compute @workgroup_size(WORKGROUP_SIZE)
fn main( @builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {

    let block_idx = group_id.x;
    let partitioning_count_selected = uniforms.partitioning_count_selected[uniforms.partition_count - 1];

    // Load data into shared memory
    for(var i = local_idx; i < SORT_ITEM_COUNT; i += WORKGROUP_SIZE) {
        s_data[i].index = i;
        if(i < partitioning_count_selected) {
            let global_idx = block_idx * BLOCK_MAX_PARTITIONINGS + i;
            s_data[i].score = mismatch_counts[global_idx];
        }
        else {
			s_data[i].score = 0xFFFFFFFFu; // max value, so these will sort to the end
		}
    }
    workgroupBarrier();


    // Preform bitonic sort
    for (var k = 2u; k <= SORT_ITEM_COUNT; k = k * 2) {

        for (var j = k / 2u; j > 0u; j = j / 2u) {

			let partner_idx = local_idx ^ j;

			if (partner_idx > local_idx) {

				let ascending = ((local_idx & k) == 0u);

                let item1 = s_data[local_idx];
                let item2 = s_data[partner_idx];

                let should_swap = (item1.score > item2.score) || (item1.score == item2.score && item1.index > item2.index);

                if (should_swap == ascending) {
					s_data[local_idx] = item2;
					s_data[partner_idx] = item1;
				}
			}
			workgroupBarrier();
		}
    }

    //Write to output buffer
    for(var i = local_idx; i < uniforms.tune_partitoning_candidate_limit; i += WORKGROUP_SIZE) {
        let out_idx = block_idx * MAX_PARTITIONING_CANDIDATE_LIMIT + i;
        partition_ordering[out_idx] = s_data[i].index;
    }
}const BLOCK_MAX_TEXELS: u32 = 144u;
const MAX_PARTITIONS: u32 = 4u;
const WORKGROUP_SIZE: u32 = 256u;
const BLOCK_MAX_PARTITIONINGS: u32 = 1024u;
const MAX_PARTITIONING_CANDIDATE_LIMIT: u32 = 512u;

const FIXED_POINT_SCALE_I32: f32 = 4096.0;


struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    tune_partitoning_candidate_limit: u32,
    _padding1: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};

struct PartitonInfo {
    partition_count: u32,
    partition_index: u32,
    _padding1: u32,
    _padding2: u32,

    partition_texel_count: array<u32, MAX_PARTITIONS>,
    partition_of_texel: array<u32, BLOCK_MAX_TEXELS>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> partitionInfos: array<PartitonInfo>;
@group(0) @binding(2) var<storage, read> inputBlocks: array<InputBlock>;
@group(0) @binding(3) var<storage, read> partition_ordering : array<u32>;

@group(0) @binding(4) var<storage, read_write> final_partitioning_errors: array<vec2<f32>>;



var<workgroup> pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>;


var<workgroup> partition_sums: array<array<atomic<u32>, 4>, MAX_PARTITIONS>;
var<workgroup> partition_counts: array<atomic<u32>, MAX_PARTITIONS>;

// For direction computation: [partition_idx][axis_sum_idx][color_channel]
// axis_sum_idx: 0=sum_xp, 1=sum_yp, 2=sum_zp, 3=sum_wp
var<workgroup> axis_sums: array<array<array<atomic<i32>, 4>, 4>, MAX_PARTITIONS>;

var<workgroup> uncor_error_sum: atomic<u32>;
var<workgroup> samec_error_sum: atomic<u32>;

var<workgroup> line_min_param: array<atomic<i32>, MAX_PARTITIONS>;
var<workgroup> line_max_param: array<atomic<i32>, MAX_PARTITIONS>;


@compute @workgroup_size(WORKGROUP_SIZE)
fn main( @builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {
    
    let block_idx = group_id.x;

    //load pixel data into shared memory
    if (local_idx < uniforms.texel_count) {
		pixels[local_idx] = inputBlocks[block_idx].pixels[local_idx];
	}
    workgroupBarrier();

    //iterate over all candidate partitionings to test
    for(var cand_idx = 0u; cand_idx < uniforms.tune_partitoning_candidate_limit; cand_idx += 1u) {
        
        let global_idx = block_idx * MAX_PARTITIONING_CANDIDATE_LIMIT + cand_idx;
        let partitioning_idx = partition_ordering[global_idx];
        let table_idx = (uniforms.partition_count - 2) * BLOCK_MAX_PARTITIONINGS + partitioning_idx;
        let pi = partitionInfos[table_idx];


        //1. Compute averages
        //initialize atomics
        if(local_idx < uniforms.partition_count) {
            atomicStore(&partition_counts[local_idx], 0u);
            for(var c = 0u; c < 4u; c += 1u) {
				atomicStore(&partition_sums[local_idx][c], 0u);
			}
        }
        workgroupBarrier();

        //accumulate sums and counts
        if(local_idx < uniforms.texel_count) {
			let pidx = pi.partition_of_texel[local_idx];
			let px = pixels[local_idx];
            let px_u = vec4<u32>(px);

			atomicAdd(&partition_counts[pidx], 1u);
            atomicAdd(&partition_sums[pidx][0], px_u.r);
            atomicAdd(&partition_sums[pidx][1], px_u.g);
            atomicAdd(&partition_sums[pidx][2], px_u.b);
            atomicAdd(&partition_sums[pidx][3], px_u.a);
		}
        workgroupBarrier();

        //finalize averages
        var avg: array<vec4<f32>, MAX_PARTITIONS>;
        if(local_idx < uniforms.partition_count) {
            let count = f32(atomicLoad(&partition_counts[local_idx]));
            if(count > 0.0) {
                avg[local_idx] = vec4<f32>(
					f32(atomicLoad(&partition_sums[local_idx][0])) / count,
					f32(atomicLoad(&partition_sums[local_idx][1])) / count,
					f32(atomicLoad(&partition_sums[local_idx][2])) / count,
					f32(atomicLoad(&partition_sums[local_idx][3])) / count
				);            
            }
        }
        workgroupBarrier();

        //2. Compute directions
        //initialize atomics
        if(local_idx < uniforms.partition_count) {
            for (var axis = 0u; axis < 4u; axis += 1u) {
                for (var c = 0u; c < 4u; c += 1u) {
                    atomicStore(&axis_sums[local_idx][axis][c], 0);
                }
            }
        }
        workgroupBarrier();

        //accumulate axis sums
        if(local_idx < uniforms.texel_count) {
            let pidx = pi.partition_of_texel[local_idx];

            let datum = pixels[local_idx] - avg[pidx];
            let datum_i = vec4<i32>(datum);

            if(datum.x > 0.0) {
                atomicAdd(&axis_sums[pidx][0][0], datum_i.r);
                atomicAdd(&axis_sums[pidx][0][1], datum_i.g);
                atomicAdd(&axis_sums[pidx][0][2], datum_i.b);
                atomicAdd(&axis_sums[pidx][0][3], datum_i.a);
            }
            if(datum.y > 0.0) {
                atomicAdd(&axis_sums[pidx][1][0], datum_i.r);
                atomicAdd(&axis_sums[pidx][1][1], datum_i.g);
                atomicAdd(&axis_sums[pidx][1][2], datum_i.b);
                atomicAdd(&axis_sums[pidx][1][3], datum_i.a);
            }
            if(datum.z > 0.0) {
                atomicAdd(&axis_sums[pidx][2][0], datum_i.r);
                atomicAdd(&axis_sums[pidx][2][1], datum_i.g);
                atomicAdd(&axis_sums[pidx][2][2], datum_i.b);
                atomicAdd(&axis_sums[pidx][2][3], datum_i.a);
            }
            if(datum.w > 0.0) {
                atomicAdd(&axis_sums[pidx][3][0], datum_i.r);
                atomicAdd(&axis_sums[pidx][3][1], datum_i.g);
                atomicAdd(&axis_sums[pidx][3][2], datum_i.b);
                atomicAdd(&axis_sums[pidx][3][3], datum_i.a);
            }
        }
        workgroupBarrier();

        //finalize directions
        var dir: array<vec4<f32>, MAX_PARTITIONS>;
        if(local_idx < uniforms.partition_count) {
            let p = local_idx;
            let sum_xp = vec4<f32>(vec4<i32>(atomicLoad(&axis_sums[p][0][0]), atomicLoad(&axis_sums[p][0][1]), atomicLoad(&axis_sums[p][0][2]), atomicLoad(&axis_sums[p][0][3])));
            let sum_yp = vec4<f32>(vec4<i32>(atomicLoad(&axis_sums[p][1][0]), atomicLoad(&axis_sums[p][1][1]), atomicLoad(&axis_sums[p][1][2]), atomicLoad(&axis_sums[p][1][3])));
            let sum_zp = vec4<f32>(vec4<i32>(atomicLoad(&axis_sums[p][2][0]), atomicLoad(&axis_sums[p][2][1]), atomicLoad(&axis_sums[p][2][2]), atomicLoad(&axis_sums[p][2][3])));
            let sum_wp = vec4<f32>(vec4<i32>(atomicLoad(&axis_sums[p][3][0]), atomicLoad(&axis_sums[p][3][1]), atomicLoad(&axis_sums[p][3][2]), atomicLoad(&axis_sums[p][3][3])));

            var best_sum = sum_xp;
            var max_prod = dot(sum_xp, sum_xp);
            
            var prod = dot(sum_yp, sum_yp);
            if(prod > max_prod) {
				max_prod = prod;
				best_sum = sum_yp;
			}
            prod = dot(sum_zp, sum_zp);
			if(prod > max_prod) {
                max_prod = prod;
                best_sum = sum_zp;
            }
            prod = dot(sum_wp, sum_wp);
            if(prod > max_prod) {
				max_prod = prod;
				best_sum = sum_wp;
			}

            dir[p] = normalize(best_sum);
        }
        workgroupBarrier();


        //3. Compute errors
        //initialize atomics
        if(local_idx == 0u) {
            atomicStore(&uncor_error_sum, 0u);
            atomicStore(&samec_error_sum, 0u);
        }
        if(local_idx < uniforms.partition_count) {
            atomicStore(&line_min_param[local_idx], 2147483647);
            atomicStore(&line_max_param[local_idx], -2147483647);
		}
        workgroupBarrier();


        //Each thread calculates it's texels contrubution to the error
        if(local_idx < uniforms.texel_count) {
            let pidx = pi.partition_of_texel[local_idx];
            let px = pixels[local_idx];

            //uncorrelated line
            let uncor_dir = dir[pidx];
            let uncor_param = dot(px, uncor_dir);
            let uncor_proj = avg[pidx] + uncor_dir * dot(px - avg[pidx], uncor_dir);
            let uncor_diff = px - uncor_proj;
            let uncor_dist_sq = dot(uncor_diff * uncor_diff, uniforms.channel_weights);

            //same chroma line
            let samec_dir = normalize(avg[pidx]);
            let samec_proj = samec_dir * dot(px, samec_dir);
            let samec_diff = px - samec_proj;
            let samec_dist_sq = dot(samec_diff * samec_diff, uniforms.channel_weights);

            atomicAdd(&uncor_error_sum, u32(uncor_dist_sq));
            atomicAdd(&samec_error_sum, u32(samec_dist_sq));

            //update line params
            let uncor_param_i = i32(uncor_param * FIXED_POINT_SCALE_I32);
            atomicMin(&line_min_param[pidx], uncor_param_i);
            atomicMax(&line_max_param[pidx], uncor_param_i);
        }
        workgroupBarrier();

        //finalize error
        if(local_idx == 0u) {
            var total_uncor_err = f32(atomicLoad(&uncor_error_sum));
            var total_samec_err = f32(atomicLoad(&samec_error_sum));

            for(var p = 0u; p < uniforms.partition_count; p += 1u) {
                let min_p = f32(atomicLoad(&line_min_param[p])) / FIXED_POINT_SCALE_I32;
                let max_p = f32(atomicLoad(&line_max_param[p])) / FIXED_POINT_SCALE_I32;
                let line_len = max(max_p - min_p, 1e-7);

                let tpp = f32(pi.partition_texel_count[p]);

                let texels_per_block = uniforms.texel_count;
                var weight_imprecision_estim = 0.055f;
                if(texels_per_block <= 20) {
                    weight_imprecision_estim = 0.03f;
                }
                else if(texels_per_block <= 31) {
                    weight_imprecision_estim = 0.04f;
                }
                else if(texels_per_block <= 41) {
                    weight_imprecision_estim = 0.05f;
                }
                weight_imprecision_estim = weight_imprecision_estim * weight_imprecision_estim;

                let error_weight = tpp * weight_imprecision_estim;

                total_uncor_err = total_uncor_err + error_weight * (line_len * line_len);
                total_samec_err = total_samec_err + error_weight * dot(avg[p], avg[p]);
            }

            let out_idx = block_idx * MAX_PARTITIONING_CANDIDATE_LIMIT + cand_idx;
            final_partitioning_errors[out_idx] = vec2<f32>(total_uncor_err, total_samec_err);
        }
        workgroupBarrier();
    }
}const BLOCK_MAX_TEXELS: u32 = 144u;
const MAX_PARTITIONS: u32 = 4u;

const WORKGROUP_SIZE: u32 = 64u;

const BLOCK_MAX_PARTITIONINGS: u32 = 1024u;
const MAX_PARTITIONING_CANDIDATE_LIMIT: u32 = 512u;
const MAX_PARTITIONINGS: u32 = 8u;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    tune_partitoning_candidate_limit: u32,
    requested_partitionings: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};

struct PartitonInfo {
    partition_count: u32,
    partition_index: u32,
    _padding1: u32,
    _padding2: u32,

    partition_texel_count: array<u32, MAX_PARTITIONS>,
    partition_of_texel: array<u32, BLOCK_MAX_TEXELS>,
};


struct BestChoice {
    index: u32,
    error: f32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> partitionInfos: array<PartitonInfo>;
@group(0) @binding(2) var<storage, read> inputBlocks: array<InputBlock>;
@group(0) @binding(3) var<storage, read> final_partitioning_errors: array<vec2<f32>>;

@group(0) @binding(4) var<storage, read_write> partitionedBlocks: array<InputBlock>;


@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {

    let blockIndex = global_id.x;


    var best_uncor: array<BestChoice, MAX_PARTITIONINGS>;
    var best_samec: array<BestChoice, MAX_PARTITIONINGS>;

    // Initialize best choices
    for (var i = 0u; i < MAX_PARTITIONINGS; i += 1u) {
        best_uncor[i] = BestChoice(0u, 1e30);
        best_samec[i] = BestChoice(0u, 1e30);
    }

    //find N best partitionings for uncorelated and same chroma colors
    for(var i = 0u; i < uniforms.tune_partitoning_candidate_limit; i += 1u) {
        let global_idx = blockIndex * MAX_PARTITIONING_CANDIDATE_LIMIT + i;
        let errors = final_partitioning_errors[global_idx];

        //uncorrelated
        if(errors.x < best_uncor[uniforms.requested_partitionings - 1u].error) {
            best_uncor[uniforms.requested_partitionings - 1u] = BestChoice(i, errors.x);

            //simple bubble-up sort
            for(var j = uniforms.requested_partitionings - 1u; j > 0u; j -= 1u) {
				if(best_uncor[j].error < best_uncor[j - 1u].error) {
					let tmp = best_uncor[j - 1u];
					best_uncor[j - 1u] = best_uncor[j];
					best_uncor[j] = tmp;
				}
			}
        }

        //same chroma
        if(errors.y < best_samec[uniforms.requested_partitionings - 1u].error) {
			best_samec[uniforms.requested_partitionings - 1u] = BestChoice(i, errors.y);

			//simple bubble-up sort
			for(var j = uniforms.requested_partitionings - 1u; j > 0u; j -= 1u) {
                if(best_samec[j].error < best_samec[j - 1u].error) {
					let tmp = best_samec[j - 1u];
					best_samec[j - 1u] = best_samec[j];
					best_samec[j] = tmp;
				}
            }
        }
    }


    //Interleave and deduplicate
    var interleave: array<u32, MAX_PARTITIONINGS * 2u>;
    for(var i = 0u; i < uniforms.requested_partitionings; i += 1u) {
		interleave[i * 2u] = best_uncor[i].index;
		interleave[i * 2u + 1u] = best_samec[i].index;
	}

    var final_indices: array<u32, MAX_PARTITIONINGS>;
    var emitted = 0u;

    for(var i = 0u; i < uniforms.requested_partitionings * 2u; i += 1u) {
        let idx = interleave[i];

        var written = false;
        for(var j = 0u; j < emitted; j += 1u) {
			if(final_indices[j] == idx) {
				written = true;
				break;
			}
		}

        if(!written) {
            final_indices[emitted] = idx;
            emitted += 1u;
            if(emitted >= uniforms.requested_partitionings) {
				break;
			}
        }
    }
    let num_final = emitted;

    //generate partitoned blocks
    let original_block = inputBlocks[blockIndex];

    for(var i = 0u; i < num_final; i += 1u) {
        let part_idx = final_indices[i];
        let table_idx = (uniforms.partition_count - 2) * BLOCK_MAX_PARTITIONINGS + part_idx;
        let pi = partitionInfos[table_idx];

        var new_block: InputBlock;

        new_block.pixels = original_block.pixels;
        new_block.grayscale = original_block.grayscale;
        new_block.constant_alpha = original_block.constant_alpha;

        new_block.partitioning_idx = pi.partition_index;
        new_block.partition_pixel_counts = pi.partition_texel_count;
        new_block.texel_partitions = pi.partition_of_texel;

        let out_idx = blockIndex * uniforms.requested_partitionings + i;
        partitionedBlocks[out_idx] = new_block;

    }

}const BLOCK_MAX_TEXELS : u32 = 144;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct IdealEndpointsAndWeights {
    partitions: array<IdealEndpointsAndWeightsPartition, 4>,
    weights: array<f32, BLOCK_MAX_TEXELS>,

    weight_error_scale: array<f32, BLOCK_MAX_TEXELS>,

    is_constant_weight_error_scale : u32,
    min_weight_cuttof : f32,
    _padding1 : u32,
    _padding2 : u32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> inputBlocks: array<InputBlock>;
@group(0) @binding(2) var<storage, read_write> outputBlocks: array<IdealEndpointsAndWeights>;

@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
    let blockIndex = global_id.x;
    let inputBlock = inputBlocks[blockIndex];

    let texelCount = uniforms.texel_count;

    let cw = uniforms.channel_weights;
    let error_weight = (cw.x + cw.y + cw.z + cw.w) / 4.0f;

    var is_constant_wes = true;

    //compute per partition averages
    var sum: array<vec4<f32>, 4>;
    var count: array<f32, 4>;
    for (var i = 0u; i < 4u; i = i + 1u) {
        sum[i] = vec4<f32>(0.0);
        count[i] = 0.0;
    }

    for (var i = 0u; i < texelCount; i = i + 1u) {
        let p = inputBlock.texel_partitions[i];
        if (p < 4u) {
            sum[p] += inputBlock.pixels[i];
            count[p] += 1.0;
        }
    }

    var avg: array<vec4<f32>, 4>;
    for (var p = 0u; p < 4u; p = p + 1u) {
        avg[p] = select(vec4<f32>(0.0), sum[p] / count[p], count[p] > 0.0);

        //store avg
        outputBlocks[blockIndex].partitions[p].avg = avg[p];
    }


    //compute dominant direction for each partition (using the method of positive deviations)

    var direction: array<vec4<f32>, 4>;
    var minProj: array<f32, 4>;
    var maxProj: array<f32, 4>;

    for (var p = 0u; p < 4u; p = p + 1u) {
        direction[p] = vec4<f32>(0.0);
        minProj[p] = 1e10;
        maxProj[p] = -1e10;
    }

    for (var i = 0u; i < texelCount; i = i + 1u) {
        let p = inputBlock.texel_partitions[i];
        if (p < 4u) {
            let diff = inputBlock.pixels[i] - avg[p];
            let pd = max(diff, vec4<f32>(0.0));
            direction[p] += pd * pd;
        }
    }

    for (var p = 0u; p < 4u; p = p + 1u) {
        direction[p] = normalize(direction[p]);

        //store dir
        outputBlocks[blockIndex].partitions[p].dir = direction[p];
    }


    //find ideal endpoints
    for (var i = 0u; i < texelCount; i = i + 1u) {
        let p = inputBlock.texel_partitions[i];
        if (p < 4u) {
            let proj = dot(inputBlock.pixels[i] - avg[p], direction[p]);
            minProj[p] = min(minProj[p], proj);
            maxProj[p] = max(maxProj[p], proj);
        }
    }

    var partition0_lenSqr = 0.0f;
    var lenghtsSqr = vec4<f32>(0.0);

    for (var p = 0u; p < 4u; p = p + 1u) {
        let d = direction[p];

        if(minProj[p] >= maxProj[p]) {
            minProj[p] = 0.0f;
            maxProj[p] = 1e-7f;
        }

        let length = maxProj[p] - minProj[p];
        let lengthSqr = length * length;

        lenghtsSqr[p] = lengthSqr;

        if (all(d == vec4<f32>(0.0))) {
            outputBlocks[blockIndex].partitions[p].endpoint0 = avg[p];
            outputBlocks[blockIndex].partitions[p].endpoint1 = avg[p];
        }
        else {
            outputBlocks[blockIndex].partitions[p].endpoint0 = avg[p] + d * minProj[p];
            outputBlocks[blockIndex].partitions[p].endpoint1 = avg[p] + d * maxProj[p];
            //outputBlocks[blockIndex].partitions[p].endpoint0 = d * minProj[p];
            //outputBlocks[blockIndex].partitions[p].endpoint1 = d * maxProj[p];
        }

        if(p == 0) {
            partition0_lenSqr = lengthSqr;
        }
        else {
            is_constant_wes = is_constant_wes && lengthSqr == partition0_lenSqr;
        }
    }

    //assign weights
    for (var i = 0u; i < texelCount; i = i + 1u) {
        let p = inputBlock.texel_partitions[i];

        if (p < 4u) {
            let proj = dot(inputBlock.pixels[i] - avg[p], direction[p]);
            let span = max(maxProj[p] - minProj[p], 1e-6);
            let w = clamp((proj - minProj[p]) / span, 0.0, 1.0);
            outputBlocks[blockIndex].weights[i] = w;

            outputBlocks[blockIndex].weight_error_scale[i] = lenghtsSqr[p] * error_weight;
        }
    }

    outputBlocks[blockIndex].is_constant_weight_error_scale = select(0u, 1u, is_constant_wes);


    //calculate min_endpoint for endpoint quality metric
    var min_ep = vec4<f32>(10.0);

    for (var p = 0u; p < 4u; p = p + 1u) {
        let ep0 = outputBlocks[blockIndex].partitions[p].endpoint0;
        let ep1 = outputBlocks[blockIndex].partitions[p].endpoint1;

        let ep = (vec4<f32>(1.0) - ep0) / (ep1 - ep0 + vec4<f32>(1e-9));  //add small value to prevent division by zero

        let use_ep_mask = (ep > vec4<f32>(0.5)) & (ep < min_ep);

        min_ep = select(min_ep, ep, use_ep_mask);
    }


    outputBlocks[blockIndex].min_weight_cuttof = min(min_ep[0], min(min_ep[1], min(min_ep[2], min_ep[3])));
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_TEXELS: u32 = 144u; // Max texels (e.g., 12x12)
const BLOCK_MAX_WEIGHTS: u32 = 64u;  // Max decimated weights (e.g., 8x8)

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct DecimationInfo {
    texel_count : u32,
    weight_count : u32,
    weight_x : u32,
    weight_y : u32,

    max_quant_level : u32,
    max_angular_steps : u32,
    max_quant_steps: u32,
    _padding: u32,

    texel_weight_count : array<u32, BLOCK_MAX_TEXELS>,
    texel_weights_offset : array<u32, BLOCK_MAX_TEXELS>,

    weight_texel_count : array<u32, BLOCK_MAX_WEIGHTS>,
    weight_texels_offset : array<u32, BLOCK_MAX_WEIGHTS>,
};

struct TexelToWeightMap {
	weight_index : u32,
	contribution : f32,

    _padding1 : u32,
    _padding2 : u32,
};

struct WeightToTexelMap {
    texel_index : u32,
	contribution : f32,

    _padding1 : u32,
    _padding2 : u32,
};

struct IdealEndpointsAndWeightsPartition { //same as OutputPartition in shader pass 1
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct IdealEndpointsAndWeights {
    partitions: array<IdealEndpointsAndWeightsPartition, 4>,
    weights: array<f32, BLOCK_MAX_TEXELS>,

    weight_error_scale: array<f32, BLOCK_MAX_TEXELS>,

    is_constant_weight_error_scale : u32,
    min_weight_cuttof : f32,
    _padding1 : u32,
    _padding2 : u32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_decimation_modes: array<u32>;
@group(0) @binding(2) var<storage, read> decimation_infos: array<DecimationInfo>;
@group(0) @binding(3) var<storage, read> texel_to_weight_map: array<TexelToWeightMap>;
@group(0) @binding(4) var<storage, read> weight_to_texel_map: array<WeightToTexelMap>;
@group(0) @binding(5) var<storage, read> ideal_endpoints_and_weights: array<IdealEndpointsAndWeights>;
@group(0) @binding(6) var<storage, read_write> output_ideal_decimated_weights: array<f32>; //output buffer


//Workgroup shared memory
//decimated weights
var<workgroup> shared_decimated_weights: array<f32, BLOCK_MAX_WEIGHTS>;

//Reconstructed weight grid from the initial estimation of decimated weights
var<workgroup> shared_infilled_weights: array<f32, BLOCK_MAX_TEXELS>;

// Temporary storage for the refinement step's error calculation (the values are actually f32, but are stored as u32)
var<workgroup> shared_error_change0: array<atomic<u32>, BLOCK_MAX_WEIGHTS>;
var<workgroup> shared_error_change1: array<atomic<u32>, BLOCK_MAX_WEIGHTS>;


//Utility function for atomic add of f32 values, since this is not supproted directly
fn atomicAdd_f32(atomic_target: ptr<workgroup, atomic<u32>>, value_to_add: f32) {
    //compare-and-swap loop: continues until the atomic exchange is successful
    loop {
        //atomically load the current value as an integer
        let original_val_uint = atomicLoad(atomic_target);

        //re-interpret the bits of the integer as a float, without conversion
        let original_val_float = bitcast<f32>(original_val_uint);

        //add float value
        let new_val_float = original_val_float + value_to_add;

        //re-interpret the bits of the new float value back to integer
        let new_val_uint = bitcast<u32>(new_val_float);

        //attempt to swap
        let result = atomicCompareExchangeWeak(atomic_target, original_val_uint, new_val_uint);

        //if the swap was successful (result.exchanged is true), break the loop
        if (result.exchanged) {
            break;
        }
    }
}


@compute @workgroup_size(WORKGROUP_SIZE)
fn main(
    @builtin(workgroup_id) group_id: vec3<u32>,
    @builtin(local_invocation_index) local_idx: u32
) {

    let block_idx = group_id.x;
    let mode_lookup_idx = group_id.y;
    let mode_idx = valid_decimation_modes[mode_lookup_idx];

    let num_valid_modes = uniforms.valid_decimation_mode_count;
    let decimation_mode_trial_idx = block_idx * num_valid_modes + mode_lookup_idx;


    if(mode_idx >= uniforms.decimation_mode_count) {
        return;
    }

    let di = decimation_infos[mode_idx];
    let ei = ideal_endpoints_and_weights[block_idx];


    // Shortcut for 1:1 mapping (direct copy)
    if (di.texel_count == di.weight_count) {
        
        for (var i = local_idx; i < di.weight_count; i += WORKGROUP_SIZE) {
            //let output_idx = (block_idx * uniforms.decimation_mode_count + mode_idx) * BLOCK_MAX_WEIGHTS + i;
            let output_idx = decimation_mode_trial_idx * BLOCK_MAX_WEIGHTS + i;
            output_ideal_decimated_weights[output_idx] = ei.weights[i];
        }
        return;
    }


    //step1: Initial estimaton of decimated weights
    for (var w = local_idx; w < di.weight_count; w += WORKGROUP_SIZE) {
        let texel_count = di.weight_texel_count[w];
        if (texel_count == 0u) {
            shared_decimated_weights[w] = 0.0;
            continue;
        }

        let texel_offset = di.weight_texels_offset[w];
        var weight_sum: f32 = 0.0;
        var total_contrib: f32 = 1e-10; // Avoid div-by-zero

        for (var j: u32 = 0u; j < texel_count; j = j + 1u) {
            let packed_idx = texel_offset + j;

            let texel_idx = weight_to_texel_map[packed_idx].texel_index;
            let contrib = weight_to_texel_map[packed_idx].contribution;

            let error_scale = ei.weight_error_scale[select(0u, texel_idx, ei.is_constant_weight_error_scale == 0u)]; //optimise memory access
            let contrib_weight = contrib * error_scale;

            weight_sum += ei.weights[texel_idx] * contrib_weight;
            total_contrib += contrib_weight;
        }
        shared_decimated_weights[w] = weight_sum / total_contrib;
    }
    workgroupBarrier(); // SYNC: Ensure all initial weights are calculated


    //step2: Bilinear Infilling
    for (var i = local_idx; i < di.texel_count; i += WORKGROUP_SIZE) {
        let weight_count = di.texel_weight_count[i];
        let weight_offset = di.texel_weights_offset[i];
        var infill_val: f32 = 0.0;

        for (var j: u32 = 0u; j < weight_count; j = j + 1u) {
            let packed_idx = weight_offset + j;

            let weight_idx = texel_to_weight_map[packed_idx].weight_index;
            let contrib = texel_to_weight_map[packed_idx].contribution;
            
            // Read from shared memory
            infill_val += shared_decimated_weights[weight_idx] * contrib;
        }

        shared_infilled_weights[i] = infill_val;
    }
    workgroupBarrier(); // SYNC: Ensure the entire infilled grid is complete


    //step3: Single refinement iteration

    //initialize the atomic error accumulators.
    if (local_idx < di.weight_count) {
        atomicStore(&shared_error_change0[local_idx], bitcast<u32>(1e-10)); // Avoid div-by-zero
        atomicStore(&shared_error_change1[local_idx], bitcast<u32>(0.0));
    }
    workgroupBarrier(); // SYNC: Ensure initialization is done.

    for (var w = local_idx; w < di.weight_count; w += WORKGROUP_SIZE) {
        let texel_count = di.weight_texel_count[w];
        if (texel_count == 0u) {
            continue;
        }

        let texel_offset = di.weight_texels_offset[w];
        for (var j: u32 = 0u; j < texel_count; j = j + 1u) {
            let packed_idx = texel_offset + j;

            let texel_idx = weight_to_texel_map[packed_idx].texel_index;
            let contrib = weight_to_texel_map[packed_idx].contribution;

            // Read from shared memory and global memory
            let old_weight = shared_infilled_weights[texel_idx];
            let ideal_weight = ei.weights[texel_idx];
            
            let error_scale = ei.weight_error_scale[select(0u, texel_idx, ei.is_constant_weight_error_scale == 0u)];
            let scale = error_scale * contrib;

            // Atomically accumulate the error changes
            atomicAdd_f32(&shared_error_change0[w], contrib * scale);
            atomicAdd_f32(&shared_error_change1[w], (old_weight - ideal_weight) * scale);
        }
    }
    workgroupBarrier(); // SYNC: Ensure all error contributions are summed

    //one thread per weight calculates the final step and updates the weight
    if (local_idx < di.weight_count) {
        let err0 = bitcast<f32>(atomicLoad(&shared_error_change0[local_idx]));
        let err1 = bitcast<f32>(atomicLoad(&shared_error_change1[local_idx]));

        let step = (err1 * -16.0) / err0; // chd_scale is -WEIGHTS_TEXEL_SUM = -16
        let clamped_step = clamp(step, -0.25, 0.25); //step size is 0.25
        
        shared_decimated_weights[local_idx] += clamped_step;
    }
    workgroupBarrier(); // SYNC: Ensure all weights are updated with the step.


    //Write refined weights from shared memory to global output
    for (var w = local_idx; w < di.weight_count; w += WORKGROUP_SIZE) {
        //let output_idx = (block_idx * uniforms.decimation_mode_count + mode_idx) * BLOCK_MAX_WEIGHTS + w;
        let output_idx = decimation_mode_trial_idx * BLOCK_MAX_WEIGHTS + w;
        output_ideal_decimated_weights[output_idx] = shared_decimated_weights[w];
    }

}

const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_TEXELS: u32 = 144u; // Max texels (e.g., 12x12)
const BLOCK_MAX_WEIGHTS: u32 = 64u;  // Max decimated weights (e.g., 8x8)
const MAX_ANGULAR_STEPS: u32 = 16u;
const SINCOS_STEPS: f32 = 1024.0;
const PI: f32 = 3.14159265358979323846;


struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct DecimationInfo {
    texel_count : u32,
    weight_count : u32,
    weight_x : u32,
    weight_y : u32,

    max_quant_level : u32,
    max_angular_steps : u32,
    max_quant_steps: u32,
    _padding: u32,

    texel_weight_count : array<u32, BLOCK_MAX_TEXELS>,
    texel_weights_offset : array<u32, BLOCK_MAX_TEXELS>,

    weight_texel_count : array<u32, BLOCK_MAX_WEIGHTS>,
    weight_texels_offset : array<u32, BLOCK_MAX_WEIGHTS>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_decimation_modes: array<u32>;
@group(0) @binding(2) var<storage, read> decimation_infos: array<DecimationInfo>;
@group(0) @binding(3) var<storage, read> sin_table_flat: array<f32>; //size is SINCOS_STEPS * MAX_ANGULAR_STEPS
@group(0) @binding(4) var<storage, read> cos_table_flat: array<f32>; //size is SINCOS_STEPS * MAX_ANGULAR_STEPS
@group(0) @binding(5) var<storage, read> ideal_decimated_weights: array<f32>; //output buffer of pass 2
@group(0) @binding(6) var<storage, read_write> output_angular_offsets: array<f32>; //output (size is decimation_mode_trails * MAX_ANGULAR_STEPS)


var<workgroup> shared_isamples: array<u32, BLOCK_MAX_WEIGHTS>;


@compute @workgroup_size(WORKGROUP_SIZE)
fn main(
    @builtin(workgroup_id) group_id: vec3<u32>,
    @builtin(local_invocation_index) local_idx: u32
) {
    let block_idx = group_id.x;
    let mode_lookup_idx = group_id.y;
    let mode_idx = valid_decimation_modes[mode_lookup_idx];

    let num_valid_modes = uniforms.valid_decimation_mode_count;
    let decimation_mode_trial_idx = block_idx * num_valid_modes + mode_lookup_idx;

    if(mode_idx >= uniforms.decimation_mode_count) {
        return;
    }

    let di = decimation_infos[mode_idx];
    let num_weights = di.weight_count;

    //precompute the sample indices
    for (var i = local_idx; i < num_weights; i += WORKGROUP_SIZE) {
        //let ideal_weight_base_idx = (block_idx * uniforms.decimation_mode_count + mode_idx) * BLOCK_MAX_WEIGHTS;
        let ideal_weight_base_idx = decimation_mode_trial_idx * BLOCK_MAX_WEIGHTS;
        let ideal_weight = ideal_decimated_weights[ideal_weight_base_idx + i];
        let sample = clamp(ideal_weight, 0.0, 1.0) * (SINCOS_STEPS - 1.0);
        shared_isamples[i] = u32(round(sample));
    }
    workgroupBarrier(); //sync

    //compute the final angular offsets
    for (var i = local_idx; i < MAX_ANGULAR_STEPS; i += WORKGROUP_SIZE) {
        var anglesum_x: f32 = 0.0;
        var anglesum_y: f32 = 0.0;
        
        // Each thread loops through all weights to calculate its assigned offset.
        for (var j: u32 = 0u; j < num_weights; j = j + 1u) {
            let isample = shared_isamples[j];
            
            //Calculate the 1D index in the flattened table
            let flat_idx = isample * MAX_ANGULAR_STEPS + i;

            anglesum_x += cos_table_flat[flat_idx];
            anglesum_y += sin_table_flat[flat_idx];
        }

        let angle = atan2(anglesum_y, anglesum_x);
        let offset = angle * (1.0 / (2.0 * PI));
        
        let output_base_idx = decimation_mode_trial_idx * MAX_ANGULAR_STEPS;
        output_angular_offsets[output_base_idx + i] = offset;
    }
}

const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const MAX_ANGULAR_STEPS: u32 = 16u;
const BLOCK_MAX_TEXELS: u32 = 144u;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct DecimationInfo {
    texel_count : u32,
    weight_count : u32,
    weight_x : u32,
    weight_y : u32,

    max_quant_level : u32,
    max_angular_steps : u32,
    max_quant_steps: u32,
    _padding: u32,

    texel_weight_count : array<u32, BLOCK_MAX_TEXELS>,
    texel_weights_offset : array<u32, BLOCK_MAX_TEXELS>,

    weight_texel_count : array<u32, BLOCK_MAX_WEIGHTS>,
    weight_texels_offset : array<u32, BLOCK_MAX_WEIGHTS>,
};

//output struct
struct HighestAndLowestWeight {
    lowest_weight : f32,
    weight_span : i32,
    error : f32,
    cut_low_error : f32,
    cut_high_error : f32,

    _padding1 : u32,
    _padding2 : u32,
    _padding3 : u32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_decimation_modes: array<u32>;
@group(0) @binding(2) var<storage, read> decimation_infos: array<DecimationInfo>;
@group(0) @binding(3) var<storage, read> ideal_decimated_weights: array<f32>; //pass2 output
@group(0) @binding(4) var<storage, read> angular_offsets: array<f32>; //pass3 output

@group(0) @binding(5) var<storage, read_write> lowest_and_highest_weights: array<HighestAndLowestWeight>; //Output of pass4


var<workgroup> shared_min_w: atomic<u32>;
var<workgroup> shared_max_w: atomic<u32>;
var<workgroup> shared_errval: atomic<u32>;
var<workgroup> shared_cut_low: atomic<u32>;
var<workgroup> shared_cut_high: atomic<u32>;


fn atomicMin_f32(atomic_target: ptr<workgroup, atomic<u32>>, value: f32) {
    let val_uint = bitcast<u32>(value);
    var current_min = atomicLoad(atomic_target);
    while (value < bitcast<f32>(current_min)) {
        let result = atomicCompareExchangeWeak(atomic_target, current_min, val_uint);
        if (result.exchanged) {
            break;
        }
        current_min = result.old_value;
    }
}

fn atomicMax_f32(atomic_target: ptr<workgroup, atomic<u32>>, value: f32) {
    let val_uint = bitcast<u32>(value);
    var current_max = atomicLoad(atomic_target);
    while (value > bitcast<f32>(current_max)) {
        let result = atomicCompareExchangeWeak(atomic_target, current_max, val_uint);
        if (result.exchanged) {
            break;
        }
        current_max = result.old_value;
    }
}

fn atomicAdd_f32(atomic_target: ptr<workgroup, atomic<u32>>, value_to_add: f32) {
    loop {
        let original_val_uint = atomicLoad(atomic_target);
        let original_val_float = bitcast<f32>(original_val_uint);
        let new_val_float = original_val_float + value_to_add;
        let new_val_uint = bitcast<u32>(new_val_float);
        let result = atomicCompareExchangeWeak(atomic_target, original_val_uint, new_val_uint);
        if (result.exchanged) {
            break;
        }
    }
}

@compute @workgroup_size(WORKGROUP_SIZE)
fn main(
   @builtin(workgroup_id) group_id: vec3<u32>,
   @builtin(local_invocation_index) local_idx: u32
) {

    let block_idx = group_id.x;
    let mode_lookup_idx = group_id.y;
    let mode_idx = valid_decimation_modes[mode_lookup_idx];

    let num_valid_modes = uniforms.valid_decimation_mode_count;
    let decimation_mode_trial_idx = block_idx * num_valid_modes + mode_lookup_idx;


    if(mode_idx >= uniforms.decimation_mode_count) {
        return;
    }
    
    let di = decimation_infos[mode_idx];
    let num_weights = di.weight_count;

    if (num_weights == 0u) {
        return;
    }


    //Parallel reduction to find global min/max ideal weights
    if (local_idx == 0u) {
        atomicStore(&shared_min_w, bitcast<u32>(3.4e38)); // FLT_MAX
        atomicStore(&shared_max_w, bitcast<u32>(-3.4e38)); // -FLT_MAX
    }
    workgroupBarrier();

    let ideal_weights_base_idx = decimation_mode_trial_idx * BLOCK_MAX_WEIGHTS;
    for (var i = local_idx; i < num_weights; i += WORKGROUP_SIZE) {
        let weight = ideal_decimated_weights[ideal_weights_base_idx + i];
        atomicMin_f32(&shared_min_w, weight);
        atomicMax_f32(&shared_max_w, weight);
    }
    workgroupBarrier();

    let min_weight = bitcast<f32>(atomicLoad(&shared_min_w));
    let max_weight = bitcast<f32>(atomicLoad(&shared_max_w));
    


    //outer loop over all angular steps. This loop is serial.
    //inner loop parallel reduction over all weights for each step.
    let angular_offsets_base_idx = decimation_mode_trial_idx * MAX_ANGULAR_STEPS;

    for (var sp = 0u; sp < di.max_angular_steps; sp = sp + 1u) {
        let rcp_stepsize = f32(sp + 1u);
        let offset = angular_offsets[angular_offsets_base_idx + sp];
        
        //pre-calculate min/max indices for this angular step
        let minidx = round(min_weight * rcp_stepsize - offset);
        let maxidx = round(max_weight * rcp_stepsize - offset);

        //initialize shared accumulators for this angular step `sp`.
        if (local_idx == 0u) {
            atomicStore(&shared_errval, bitcast<u32>(0.0));
            atomicStore(&shared_cut_low, bitcast<u32>(0.0));
            atomicStore(&shared_cut_high, bitcast<u32>(0.0));
        }
        workgroupBarrier();

        for (var j = local_idx; j < num_weights; j += WORKGROUP_SIZE) {
            let sval = ideal_decimated_weights[ideal_weights_base_idx + j] * rcp_stepsize - offset;
            let svalrte = round(sval);
            let diff = sval - svalrte;
            
            atomicAdd_f32(&shared_errval, diff * diff);

            //if (svalrte == minidx) {
            //    atomicAdd_f32(&shared_cut_low, 1.0 - (2.0 * diff));
            //}
            //if (svalrte == maxidx) {
            //    atomicAdd_f32(&shared_cut_high, 1.0 + (2.0 * diff));
            //}

            //without if statements to avoid divergent threads
            let cut_low_val_to_add = select(0.0, 1.0 - (2.0 * diff), svalrte == minidx);
            atomicAdd_f32(&shared_cut_low, cut_low_val_to_add);

            let cut_high_val_to_add = select(0.0, 1.0 + (2.0 * diff), svalrte == maxidx);
            atomicAdd_f32(&shared_cut_high, cut_high_val_to_add);
        }
        workgroupBarrier();

        //one thread finalizes results for this angular step
        if (local_idx == 0u) {
            let span = i32(maxidx - minidx + 1.0);
            let clamped_span = clamp(span, 2, i32(di.max_quant_steps + 3u));
            
            let ssize = 1.0 / rcp_stepsize;
            let errscale = ssize * ssize;
            
            let final_error = bitcast<f32>(atomicLoad(&shared_errval)) * errscale;
            let final_cut_low = bitcast<f32>(atomicLoad(&shared_cut_low)) * errscale;
            let final_cut_high = bitcast<f32>(atomicLoad(&shared_cut_high)) * errscale;

            let output_base_idx = decimation_mode_trial_idx * MAX_ANGULAR_STEPS;
            let output_ptr = &lowest_and_highest_weights[output_base_idx + sp];

            (*output_ptr).lowest_weight = minidx;
            (*output_ptr).weight_span = clamped_span;
            (*output_ptr).error = final_error;
            (*output_ptr).cut_low_error = final_cut_low;
            (*output_ptr).cut_high_error = final_cut_high;
        }
        //no barrier needed here, as the next loop iteration is independent.
    }
}const WORKGROUP_SIZE: u32 = 64u;
const MAX_ANGULAR_QUANT = 12; // The max number of distinct quant levels to test
const MAX_BEST_RESULTS = 36;  // A safe upper bound for the best_results array size
const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const MAX_ANGULAR_STEPS: u32 = 16u;

const STEPS_FOR_QUANT_LEVEL = array(
	2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32
);

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct DecimationInfo {
    texel_count : u32,
    weight_count : u32,
    weight_x : u32,
    weight_y : u32,

    max_quant_level : u32,
    max_angular_steps : u32,
    max_quant_steps: u32,
    _padding: u32,

    texel_weight_count : array<u32, BLOCK_MAX_TEXELS>,
    texel_weights_offset : array<u32, BLOCK_MAX_TEXELS>,

    weight_texel_count : array<u32, BLOCK_MAX_WEIGHTS>,
    weight_texels_offset : array<u32, BLOCK_MAX_WEIGHTS>,
};

struct HighestAndLowestWeight {
    lowest_weight : f32,
    weight_span : i32,
    error : f32,
    cut_low_error : f32,
    cut_high_error : f32,

    _padding1 : f32,
    _padding2 : f32,
    _padding3 : f32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_decimation_modes: array<u32>;
@group(0) @binding(2) var<storage, read> decimation_infos: array<DecimationInfo>;
@group(0) @binding(3) var<storage, read> angular_offsets: array<f32>; //pass3 output
@group(0) @binding(4) var<storage, read> lowest_and_highest_weights: array<HighestAndLowestWeight>; //Output of pass4

@group(0) @binding(5) var<storage, read_write> output_final_low_values: array<f32>;
@group(0) @binding(6) var<storage, read_write> output_final_high_values: array<f32>;


//here we pack 3 values into a vector for efficiency and to be consistant with the ARM implementation
//val0: error
//val1: best_step_index (stored as f32)
//val2: cut_low_flag (0.0 if flase, 1.0 if true)
var<workgroup> shared_best_results: array<vec3<f32>, MAX_BEST_RESULTS>;

@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {

    let block_idx = group_id.x;
    let mode_lookup_idx = group_id.y;
    let mode_idx = valid_decimation_modes[mode_lookup_idx];

    let num_valid_modes = uniforms.valid_decimation_mode_count;
    let decimation_mode_trial_idx = block_idx * num_valid_modes + mode_lookup_idx;


    if(mode_idx >= uniforms.decimation_mode_count) {
        return;
    }

    let di = decimation_infos[mode_idx];

    //initalization
    for (var i = local_idx; i < di.max_quant_steps + 4u; i += WORKGROUP_SIZE) {
        if (i < MAX_BEST_RESULTS) {
            shared_best_results[i] = vec3(1e37, -1.0, 0.0);
        }
    }
    workgroupBarrier();

    //serial reduction. One thread performs the small, complex loop.
    if (local_idx == 0u) {
        let trial_results_base_idx = decimation_mode_trial_idx * MAX_ANGULAR_STEPS;
        for (var i = 0u; i < di.max_angular_steps; i = i + 1u) {
            let trial_idx = trial_results_base_idx + i;
            let i_flt = f32(i);
            
            let idx_span = lowest_and_highest_weights[trial_idx].weight_span;
            let error = lowest_and_highest_weights[trial_idx].error;
            let cut_low_err = lowest_and_highest_weights[trial_idx].cut_low_error;
            let cut_high_err = lowest_and_highest_weights[trial_idx].cut_high_error;
            
            let error_cut_low = error + cut_low_err;
            let error_cut_high = error + cut_high_err;
            let error_cut_low_high = error + cut_low_err + cut_high_err;


            // Check against record N (span)
            var best_result = shared_best_results[idx_span];
            var new_result = vec3(error, i_flt, 0.0);
            shared_best_results[idx_span] = select(best_result, new_result, error < best_result[0]); //best result[0] corresponds to error of best result

            // Check against record N-1 (span - 1) (cut_low)
            best_result = shared_best_results[idx_span - 1];
            new_result = vec3(error_cut_low, i_flt, 1.0);
            shared_best_results[idx_span - 1] = select(best_result, new_result, error_cut_low < best_result[0]);

            // Check against record N-1 (span - 1) (cut_high)
            best_result = shared_best_results[idx_span - 1];
            new_result = vec3(error_cut_high, i_flt, 0.0);
            shared_best_results[idx_span - 1] = select(best_result, new_result, error_cut_high < best_result[0]);

            // Check against record N-2 (span - 2)
            best_result = shared_best_results[idx_span - 2];
            new_result = vec3(error_cut_low_high, i_flt, 1.0);
            shared_best_results[idx_span - 2] = select(best_result, new_result, error_cut_low_high < best_result[0]);

        }
    }
    workgroupBarrier();

    //finalization
    for (var i = local_idx; i <= di.max_quant_level; i += WORKGROUP_SIZE) {
        let q_level_idx = i;
        let q_steps = STEPS_FOR_QUANT_LEVEL[q_level_idx]; // The number of steps, e.g., 12

        // Read the final winning result from shared memory
        let winner = shared_best_results[q_steps];
        var bsi_signed = i32(winner[1]); //best step index
        bsi_signed = max(bsi_signed, 0); // Handle the -1 "not found" case
        let bsi = u32(bsi_signed);

        let trial_results_base_idx = decimation_mode_trial_idx * MAX_ANGULAR_STEPS;
        let lwi = lowest_and_highest_weights[trial_results_base_idx + bsi].lowest_weight + winner[2]; //winner[2] corresponds to cut_low_flag
        let hwi = lwi + f32(q_steps) - 1.0;
        
        let stepsize = 1.0 / (1.0 + f32(bsi));
        let offset = angular_offsets[trial_results_base_idx + bsi];

        let low_val = (offset + lwi) * stepsize;
        let high_val = (offset + hwi) * stepsize;

        let output_base_idx = decimation_mode_trial_idx * (MAX_ANGULAR_QUANT + 1);
        output_final_low_values[output_base_idx + q_level_idx] = low_val;
        output_final_high_values[output_base_idx + q_level_idx] = high_val;
    }
}const WORKGROUP_SIZE: u32 = 64u;
const MAX_ANGULAR_QUANT = 12;
const MAX_BEST_RESULTS = 36;
const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const MAX_ANGULAR_STEPS: u32 = 16u;


struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct PackedBlockModeLookup {
    block_mode_index: u32,
    decimation_mode_lookup_idx: u32, //index of corresponding decimation mode in the valid decimation modes buffer

    _padding1: u32,
    _padding2: u32,
};

struct BlockMode {
	mode_index : u32,
    decimation_mode : u32,
    quant_mode : u32,
    weight_bits : u32,
    is_dual_plane : u32,

    _padding1 : u32,
    _padding2 : u32,
    _padding3 : u32,
};

struct FinalValueRange {
    low : f32,
    high : f32,

    _padding1 : u32,
    _padding2 : u32,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_block_modes: array<PackedBlockModeLookup>;
@group(0) @binding(2) var<storage, read> block_modes: array<BlockMode>;
@group(0) @binding(3) var<storage, read> source_low_values: array<f32>;
@group(0) @binding(4) var<storage, read> source_high_values: array<f32>;

@group(0) @binding(5) var<storage, read_write> output_final_value_ranges: array<FinalValueRange>;


@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {

    let block_index = global_id.x;
    let bm_lookup_idx = global_id.y;
    let block_mode_index = valid_block_modes[bm_lookup_idx].block_mode_index;

    let num_valid_bms = uniforms.valid_block_mode_count;
    let num_valid_dms = uniforms.valid_decimation_mode_count;

    let block_mode_trial_index = block_index * num_valid_bms + bm_lookup_idx;
    let decimation_mode_trial_index = block_index * num_valid_dms + valid_block_modes[bm_lookup_idx].decimation_mode_lookup_idx;

    let bm = block_modes[block_mode_index];

    let quant_mode = bm.quant_mode;

    // Check if the quantization level is within the range handled by the angular search.
    if (quant_mode <= MAX_ANGULAR_QUANT) {   
        let source_idx = decimation_mode_trial_index * (MAX_ANGULAR_QUANT + 1) + quant_mode;

        output_final_value_ranges[block_mode_trial_index].low = source_low_values[source_idx];
        output_final_value_ranges[block_mode_trial_index].high = source_high_values[source_idx];
    } else {
        output_final_value_ranges[block_mode_trial_index].low = 0.0;
        output_final_value_ranges[block_mode_trial_index].high = 1.0;
    }
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;

const FREE_BITS_FOR_PARTITION_COUNT = array<i32, 4>(111, 111 - 4 - 10, 108 - 4 - 10, 105 - 4 - 10);
const QUANT_MODES = array<u32, 12>(2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32);

const QUANT_TABLE_OFFSETS = array<u32, 12>(0, 2, 5, 9, 14, 20, 28, 38, 50, 66, 86, 110);

//packed values of quant_to_unquant table from the ARM implementation
//get offset for quantization level from QUANT_TABLE_OFFSETS
const QUANT_TO_UNQUANT = array<u32, 142>(
    // QUANT_2
    0u, 64u,
    // QUANT_3
    0u, 32u, 64u,
    // QUANT_4
    0u, 21u, 43u, 64u,
    // QUANT_5
    0u, 16u, 32u, 48u, 64u,
    // QUANT_6
    0u, 12u, 25u, 39u, 52u, 64u,
    // QUANT_8
    0u, 9u, 18u, 27u, 37u, 46u, 55u, 64u,
    // QUANT_10
    0u, 7u, 14u, 21u, 28u, 36u, 43u, 50u, 57u, 64u,
    // QUANT_12
    0u, 5u, 11u, 17u, 23u, 28u, 36u, 41u, 47u, 53u, 59u, 64u,
    // QUANT_16
    0u, 4u, 8u, 12u, 17u, 21u, 25u, 29u, 35u, 39u, 43u, 47u, 52u, 56u, 60u, 64u,
    // QUANT_20
    0u, 3u, 6u, 9u, 13u, 16u, 19u, 23u, 26u, 29u, 35u, 38u, 41u, 45u, 48u, 51u, 55u, 58u, 61u, 64u,
    // QUANT_24
    0u, 2u, 5u, 8u, 11u, 13u, 16u, 19u, 22u, 24u, 27u, 30u, 34u, 37u, 40u, 42u, 45u, 48u, 51u, 53u, 56u, 59u, 62u, 64u,
    // QUANT_32
    0u, 2u, 4u, 6u, 8u, 10u, 12u, 14u, 16u, 18u, 20u, 22u, 24u, 26u, 28u, 30u, 34u, 36u, 38u, 40u, 42u, 44u, 46u, 48u, 50u, 52u, 54u, 56u, 58u, 60u, 62u, 64u,
);


struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct PackedBlockModeLookup {
    block_mode_index: u32,
    decimation_mode_lookup_idx: u32, //index of corresponding decimation mode in the valid decimation modes buffer

    _padding1: u32,
    _padding2: u32,
};

struct BlockMode {
	mode_index : u32,
    decimation_mode : u32,
    quant_mode : u32,
    weight_bits : u32,
    is_dual_plane : u32,

    _padding1 : u32,
    _padding2 : u32,
    _padding3 : u32,
};

struct DecimationInfo {
    texel_count : u32,
    weight_count : u32,
    weight_x : u32,
    weight_y : u32,

    max_quant_level : u32,
    max_angular_steps : u32,
    max_quant_steps: u32,
    _padding: u32,

    texel_weight_count : array<u32, BLOCK_MAX_TEXELS>,
    texel_weights_offset : array<u32, BLOCK_MAX_TEXELS>,

    weight_texel_count : array<u32, BLOCK_MAX_WEIGHTS>,
    weight_texels_offset : array<u32, BLOCK_MAX_WEIGHTS>,
};

struct FinalValueRange {
    low : f32,
    high : f32,

    _padding1 : u32,
    _padding2 : u32,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct IdealEndpointsAndWeights {
    partitions: array<IdealEndpointsAndWeightsPartition, 4>,
    weights: array<f32, BLOCK_MAX_TEXELS>,

    weight_error_scale: array<f32, BLOCK_MAX_TEXELS>,

    is_constant_weight_error_scale : u32,
    min_weight_cuttof : f32,
    _padding1 : u32,
    _padding2 : u32,
};

struct TexelToWeightMap {
	weight_index : u32,
	contribution : f32,

    _padding1 : u32,
    _padding2 : u32,
};

struct QuantizationResult {
    error: f32,
    bitcount: i32,

    _padding1: u32,
    _padding2: u32,

    quantized_weights: array<u32, (BLOCK_MAX_WEIGHTS/4)>,
};

@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_block_modes: array<PackedBlockModeLookup>;
@group(0) @binding(2) var<storage, read> block_modes: array<BlockMode>;
@group(0) @binding(3) var<storage, read> decimation_infos: array<DecimationInfo>;
@group(0) @binding(4) var<storage, read> ideal_decimated_weights: array<f32>;
@group(0) @binding(5) var<storage, read> final_value_ranges: array<FinalValueRange>;
@group(0) @binding(6) var<storage, read> ideal_endpoints_and_weights: array<IdealEndpointsAndWeights>;
@group(0) @binding(7) var<storage, read> texel_to_weight_map: array<TexelToWeightMap>;

@group(0) @binding(8) var<storage, read_write> output_quantization_results: array<QuantizationResult>;


fn atomicAdd_f32(atomic_target: ptr<workgroup, atomic<u32>>, value_to_add: f32) {
    loop {
        let original_val_uint = atomicLoad(atomic_target);
        let original_val_float = bitcast<f32>(original_val_uint);
        let new_val_float = original_val_float + value_to_add;
        let new_val_uint = bitcast<u32>(new_val_float);
        let result = atomicCompareExchangeWeak(atomic_target, original_val_uint, new_val_uint);
        if (result.exchanged) {
            break;
        }
    }
}




var<workgroup> shared_skip_work: u32;
var<workgroup> shared_bitcount: i32; // Store bitcount for the final writer thread
var<workgroup> shared_quantized_weights_float: array<f32, BLOCK_MAX_WEIGHTS>;
var<workgroup> shared_quantized_weights_int: array<u32, BLOCK_MAX_WEIGHTS>;
var<workgroup> shared_infilled_weights: array<f32, BLOCK_MAX_TEXELS>;
var<workgroup> shared_total_error: atomic<u32>;

@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {

    let block_index = group_id.x;
    let bm_lookup_idx = group_id.y;
    let block_mode_index = valid_block_modes[bm_lookup_idx].block_mode_index;

    let num_valid_bms = uniforms.valid_block_mode_count;
    let num_valid_dms = uniforms.valid_decimation_mode_count;

    let block_mode_trial_index = block_index * num_valid_bms + bm_lookup_idx;
    let decimation_mode_trial_index = block_index * num_valid_dms + valid_block_modes[bm_lookup_idx].decimation_mode_lookup_idx;

    let bm = block_modes[block_mode_index];

    //step 1: setup and filtering
    if (local_idx == 0u) {
        shared_skip_work = 0u;

        let max_weight_quant = min(uniforms.quant_limit, 11u); //QUANT_32

        if (bm.quant_mode > max_weight_quant) {
            output_quantization_results[block_mode_trial_index].error = 1e38;
            output_quantization_results[block_mode_trial_index].bitcount = 0;
            shared_skip_work = 1u;
        } else {
            let bc = FREE_BITS_FOR_PARTITION_COUNT[uniforms.partition_count - 1] - i32(bm.weight_bits);
            if (bc <= 0) {
                output_quantization_results[block_mode_trial_index].error = 1e38;
                output_quantization_results[block_mode_trial_index].bitcount = 0;
                shared_skip_work = 1u;
            } else {
                shared_bitcount = bc;
            }
        }
    }
    workgroupBarrier();

    if (workgroupUniformLoad(&shared_skip_work) == 1u) {
        return;
    }


    let di = decimation_infos[bm.decimation_mode];
    let ei = ideal_endpoints_and_weights[block_index];
    var value_range = final_value_ranges[block_mode_trial_index];

    if(value_range.high > 1.02f * ei.min_weight_cuttof) {
        value_range.high = 1.0;
    }

    if (value_range.high <= value_range.low) {
        value_range.low = 0.0;
        value_range.high = 1.0;
    }

    //step 2: compute quantized weights
    let num_weights = di.weight_count;
    let quant_steps = f32(QUANT_MODES[bm.quant_mode]);

    let quant_level = bm.quant_mode;
    let quant_level_m1 = f32(QUANT_MODES[quant_level] - 1u);

    var rscale = value_range.high - value_range.low;
    let scale = 1.0 / rscale;

    let scaled_low_bound = value_range.low * scale;
    rscale = rscale / 64.0f;

    let ideal_weight_base_idx = decimation_mode_trial_index * BLOCK_MAX_WEIGHTS;

    for (var i = local_idx; i < num_weights; i += WORKGROUP_SIZE) {
        let ideal_weight = ideal_decimated_weights[ideal_weight_base_idx + i];

        let ix = clamp(ideal_weight * scale - scaled_low_bound, 0.0, 1.0);

        let ix1 = ix * quant_level_m1;
        let weightl = u32(ix1);
        let weighth = min(weightl + 1u, u32(quant_level_m1));

        let table_base_idx = QUANT_TABLE_OFFSETS[quant_level];
        let ixli = QUANT_TO_UNQUANT[table_base_idx + weightl];
        let ixhi = QUANT_TO_UNQUANT[table_base_idx + weighth];
    
        let ixl = f32(ixli);
        let ixh = f32(ixhi);

        // Find the best match
        let use_high = (ixl + ixh) < (128.0 * ix);
        let weight_int = select(ixli, ixhi, use_high);
        let unquant_val = select(ixl, ixh, use_high);

        // Store the results
        shared_quantized_weights_int[i] = weight_int;
        // Rescale the unquantized value back to the original range
        shared_quantized_weights_float[i] = unquant_val * rscale + value_range.low;
    }
    workgroupBarrier();



    //step 3: Compute error of quantized weights
    if (local_idx == 0u) {
        atomicStore(&shared_total_error, bitcast<u32>(0.0));
    }
    workgroupBarrier();


    //bilinear infill using the newly quantized weights
    for (var i = local_idx; i < di.texel_count; i += WORKGROUP_SIZE) {
        let weight_count = di.texel_weight_count[i];
        let weight_offset = di.texel_weights_offset[i];
        var infill_val: f32 = 0.0;
        
        for (var j: u32 = 0u; j < weight_count; j = j + 1u) {
            let mapping = texel_to_weight_map[weight_offset + j];
            infill_val += shared_quantized_weights_float[mapping.weight_index] * mapping.contribution;
        }
        shared_infilled_weights[i] = infill_val;
    }
    workgroupBarrier();
    
    //sum the squared error
    for (var i = local_idx; i < di.texel_count; i += WORKGROUP_SIZE) {
        let diff = shared_infilled_weights[i] - ei.weights[i];
        let error_scale = ei.weight_error_scale[select(0u, i, ei.is_constant_weight_error_scale == 0u)];
        atomicAdd_f32(&shared_total_error, diff * diff * error_scale);
    }
    workgroupBarrier();

    //step4: store final values
    //one thread writes the error and bitcount
    if (local_idx == 0u) {
        let result_ptr = &output_quantization_results[block_mode_trial_index];
        (*result_ptr).error = bitcast<f32>(atomicLoad(&shared_total_error));
        (*result_ptr).bitcount = shared_bitcount;
    }

    // All threads help copy the final integer weights to global memory.
    for (var i = local_idx; i < num_weights/4; i += WORKGROUP_SIZE) {
        let result_ptr = &output_quantization_results[block_mode_trial_index];
        let packed = pack4xU8(vec4<u32>(
			shared_quantized_weights_int[i * 4 + 0],
			shared_quantized_weights_int[i * 4 + 1],
			shared_quantized_weights_int[i * 4 + 2],
			shared_quantized_weights_int[i * 4 + 3]
		));
        (*result_ptr).quantized_weights[i] = packed;
    }
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_TEXELS: u32 = 144u;

const DEFAULT_ALPHA: f32 = 65536.0;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct IdealEndpointsAndWeights {
    partitions: array<IdealEndpointsAndWeightsPartition, 4>,
    weights: array<f32, BLOCK_MAX_TEXELS>,

    weight_error_scale: array<f32, BLOCK_MAX_TEXELS>,

    is_constant_weight_error_scale : u32,
    min_weight_cuttof : f32,
    _padding1 : u32,
    _padding2 : u32,
};

struct EncodingChoiceErrors {
    rgb_scale_error: f32,
    rgb_luma_error: f32,
    luminance_error: f32,
    alpha_drop_error: f32,

    can_offset_encode: u32,
    can_blue_contract: u32,

    _padding1: u32,
    _padding2: u32,
}

struct ProcessedLine {
	amod: vec4<f32>,
    bs: vec4<f32>,
}

@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> inputBlocks: array<InputBlock>;
@group(0) @binding(2) var<storage, read> ideal_endpoints_and_weights: array<IdealEndpointsAndWeights>;

@group(0) @binding(3) var<storage, read_write> encoding_choice_errors: array<EncodingChoiceErrors>;


var<workgroup> shared_sum_xp: array<atomic<u32>, 16>;
var<workgroup> shared_sum_yp: array<atomic<u32>, 16>;
var<workgroup> shared_sum_zp: array<atomic<u32>, 16>;

var<workgroup> averages: array<vec4<f32>, 4>;
var<workgroup> directions: array<vec4<f32>, 4>;

var<workgroup> uncor_rgb_plines: array<ProcessedLine, 4>;
var<workgroup> samec_rgb_plines: array<ProcessedLine, 4>;
var<workgroup> rgb_luma_plines: array<ProcessedLine, 4>;
var<workgroup> luminance_plines: array<ProcessedLine, 4>;

// Accumulators for the 5 error types for each of the 4 partitions (5 * 4 = 20)
var<workgroup> error_accumulators: array<atomic<u32>, 20>;


fn atomicAdd_f32(atomic_target: ptr<workgroup, atomic<u32>>, value_to_add: f32) {
    loop {
        let original_val_uint = atomicLoad(atomic_target);
        let original_val_float = bitcast<f32>(original_val_uint);
        let new_val_float = original_val_float + value_to_add;
        let new_val_uint = bitcast<u32>(new_val_float);
        let result = atomicCompareExchangeWeak(atomic_target, original_val_uint, new_val_uint);
        if (result.exchanged) {
            break;
        }
    }
}

@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {
    
    let block_index = group_id.x;
    let partitionCount = uniforms.partition_count;

    //compute averages and directions for partitions
    let input_block = inputBlocks[block_index];
    let ideal_endpoints_and_weights_block = ideal_endpoints_and_weights[block_index];

    //Initialize shared memory
    for(var i = local_idx; i < 16; i += WORKGROUP_SIZE) {
		atomicStore(&shared_sum_xp[i], bitcast<u32>(0.0));
        atomicStore(&shared_sum_yp[i], bitcast<u32>(0.0));
        atomicStore(&shared_sum_zp[i], bitcast<u32>(0.0));
	}

    workgroupBarrier();

    // Calculate averages and directions for all partitions simultaneously
    for(var i = local_idx; i < uniforms.texel_count; i += WORKGROUP_SIZE) {
        let p = input_block.texel_partitions[i];

		if (p < partitionCount) {
			let average = ideal_endpoints_and_weights_block.partitions[p].avg;
            var texel_datum = input_block.pixels[i] - average;
            texel_datum.w = 0.0; // Ignore alpha channel for direction calculation

            if(texel_datum.x > 0.0) {
                atomicAdd_f32(&shared_sum_xp[p * 4u + 0u], texel_datum.x);
                atomicAdd_f32(&shared_sum_xp[p * 4u + 1u], texel_datum.y);
                atomicAdd_f32(&shared_sum_xp[p * 4u + 2u], texel_datum.z);
                atomicAdd_f32(&shared_sum_xp[p * 4u + 3u], texel_datum.w);
            }
            if(texel_datum.y > 0.0) {
                atomicAdd_f32(&shared_sum_yp[p * 4u + 0u], texel_datum.x);
				atomicAdd_f32(&shared_sum_yp[p * 4u + 1u], texel_datum.y);
				atomicAdd_f32(&shared_sum_yp[p * 4u + 2u], texel_datum.z);
                atomicAdd_f32(&shared_sum_yp[p * 4u + 3u], texel_datum.w);
            }
            if(texel_datum.z > 0.0) {
				atomicAdd_f32(&shared_sum_zp[p * 4u + 0u], texel_datum.x);
                atomicAdd_f32(&shared_sum_zp[p * 4u + 1u], texel_datum.y);
                atomicAdd_f32(&shared_sum_zp[p * 4u + 2u], texel_datum.z);
                atomicAdd_f32(&shared_sum_zp[p * 4u + 3u], texel_datum.w);
            }
		}
	}

    workgroupBarrier();

    //One thread per partition calculates the best direction
    if(local_idx < partitionCount) {
        let p = local_idx;

        let sum_xp = vec4<f32>(
			bitcast<f32>(atomicLoad(&shared_sum_xp[p * 4u + 0u])),
			bitcast<f32>(atomicLoad(&shared_sum_xp[p * 4u + 1u])),
			bitcast<f32>(atomicLoad(&shared_sum_xp[p * 4u + 2u])),
            bitcast<f32>(atomicLoad(&shared_sum_xp[p * 4u + 3u]))
		);
        let sum_yp = vec4<f32>(
            bitcast<f32>(atomicLoad(&shared_sum_yp[p * 4u + 0u])),
            bitcast<f32>(atomicLoad(&shared_sum_yp[p * 4u + 1u])),
            bitcast<f32>(atomicLoad(&shared_sum_yp[p * 4u + 2u])),
            bitcast<f32>(atomicLoad(&shared_sum_yp[p * 4u + 3u]))
        );
        let sum_zp = vec4<f32>(
            bitcast<f32>(atomicLoad(&shared_sum_zp[p * 4u + 0u])),
            bitcast<f32>(atomicLoad(&shared_sum_zp[p * 4u + 1u])),
            bitcast<f32>(atomicLoad(&shared_sum_zp[p * 4u + 2u])),
            bitcast<f32>(atomicLoad(&shared_sum_zp[p * 4u + 3u]))
        );

        let prod_xp = dot(sum_xp, sum_xp);
        let prod_yp = dot(sum_yp, sum_yp);
        let prod_zp = dot(sum_zp, sum_zp);

        var best_vector = sum_xp;
        var best_sum = prod_xp;

        if(prod_yp > best_sum) {
			best_vector = sum_yp;
			best_sum = prod_yp;
		}
        if(prod_zp > best_sum) {
            best_vector = sum_zp;
            best_sum = prod_zp;
        }

        directions[p] = best_vector;
        averages[p] = vec4<f32>(ideal_endpoints_and_weights_block.partitions[p].avg.xyz, 0.0);
    }

    workgroupBarrier();


    //Prepare processed lines for different endpoint encodings
    if(local_idx < partitionCount) {
        let p = local_idx;
        let avg = averages[p];
        let dir = directions[p];
        //let avg = vec4<f32>(ideal_endpoints_and_weights_block.partitions[p].avg.xyz, 0.0);
        //let dir = vec4<f32>(ideal_endpoints_and_weights_block.partitions[p].dir.xyz, 0.0);

        //Uncorrelated RGB line
        let uncor_b = normalize(dir);
        uncor_rgb_plines[p] = ProcessedLine(avg - uncor_b * dot(avg, uncor_b), uncor_b);

        //Same Chroma line (goes through origin)
        let samec_b = normalize(avg);
        samec_rgb_plines[p] = ProcessedLine(vec4<f32>(0.0), samec_b);

        //RGB Luma line (direction is unit vector)
        let luma_b = normalize(vec4<f32>(1.0, 1.0, 1.0, 0.0));
        rgb_luma_plines[p] = ProcessedLine(avg - luma_b * dot(avg, luma_b), luma_b);

        //Luminance line (goes through origin, direction is unit vector)
        luminance_plines[p] = ProcessedLine(vec4<f32>(0.0), normalize(vec4<f32>(1.0, 1.0, 1.0, 0.0)));
    }

    workgroupBarrier();


    //Compute squared errors for encoding choices
    //initialize error accumulators
    for(var i = local_idx; i < 20; i += WORKGROUP_SIZE) {
		atomicStore(&error_accumulators[i], bitcast<u32>(0.0));
	}

    workgroupBarrier();

    for(var i = local_idx; i < uniforms.texel_count; i += WORKGROUP_SIZE) {
        let p = input_block.texel_partitions[i];

        if(p < partitionCount) {

            let cw = uniforms.channel_weights;
            let rgb_data = input_block.pixels[i].xyz;

            //Alpha drop error
            let alpha_diff = input_block.pixels[i].a - DEFAULT_ALPHA;
            let a_drop_error = alpha_diff * alpha_diff * cw.w;
            atomicAdd_f32(&error_accumulators[p * 5u + 0u], a_drop_error);

            //Uncorrelated RGB error
            let uncor_rgb_line_a = uncor_rgb_plines[p].amod.xyz;
            let uncor_rgb_line_b = uncor_rgb_plines[p].bs.xyz;
            let distance_uncor = (uncor_rgb_line_a + dot(rgb_data, uncor_rgb_line_b) * uncor_rgb_line_b) - rgb_data;
            let uncor_rgb_error = dot(distance_uncor * distance_uncor, cw.xyz);
            atomicAdd_f32(&error_accumulators[p * 5u + 1u], uncor_rgb_error);

            //Same Chroma RGB error
            let samec_rgb_line_b = samec_rgb_plines[p].bs.xyz;
            let distance_samec = dot(rgb_data, samec_rgb_line_b) * samec_rgb_line_b - rgb_data;
            let samec_rgb_error = dot(distance_samec * distance_samec, cw.xyz);
            atomicAdd_f32(&error_accumulators[p * 5u + 2u], samec_rgb_error);

            //RGB Luma error
            let rgb_luma_line_a = rgb_luma_plines[p].amod.xyz;
            let rgb_luma_line_b = rgb_luma_plines[p].bs.xyz;
            let distance_rgb_luma = (rgb_luma_line_a + dot(rgb_data, rgb_luma_line_b) * rgb_luma_line_b) - rgb_data;
            let rgb_luma_error = dot(distance_rgb_luma * distance_rgb_luma, cw.xyz);
            atomicAdd_f32(&error_accumulators[p * 5u + 3u], rgb_luma_error);

            //Luminance error
            let luminance_line_b = luminance_plines[p].bs.xyz;
            let distance_luminance = dot(rgb_data, luminance_line_b) * luminance_line_b - rgb_data;
            let luminance_error = dot(distance_luminance * distance_luminance, cw.xyz);
            atomicAdd_f32(&error_accumulators[p * 5u + 4u], luminance_error);
        }
    }

    workgroupBarrier();


    //Store the accumulated errors for each partition
    if(local_idx < partitionCount) {
        let p = local_idx;

        // Load the final summed errors from the accumulators
        let alpha_drop_err = bitcast<f32>(atomicLoad(&error_accumulators[p * 5u + 0u]));
        let uncorr_err =     bitcast<f32>(atomicLoad(&error_accumulators[p * 5u + 1u]));
        let samec_err =      bitcast<f32>(atomicLoad(&error_accumulators[p * 5u + 2u]));
        let rgb_luma_err =   bitcast<f32>(atomicLoad(&error_accumulators[p * 5u + 3u]));
        let luma_err =       bitcast<f32>(atomicLoad(&error_accumulators[p * 5u + 4u]));

        //determine if offset encoding is possible
        let ep0 = ideal_endpoints_and_weights_block.partitions[p].endpoint0;
        let ep1 = ideal_endpoints_and_weights_block.partitions[p].endpoint1;
        let ep_diff = abs(ep1 - ep0);
        let ep_can_offset = ep_diff < vec4<f32>(0.12f * 65536.0);
        let can_offset_encode = select(0u, 1u, ep_can_offset.x && ep_can_offset.y && ep_can_offset.z);

        var can_blue_contract = 1u; //0 if block is grayscale with constant alpha, 1 otherwise
        if(input_block.grayscale == 1u && input_block.constant_alpha == 1u) {
            can_blue_contract = 0u;
        }

        //Store errors
        //errors are weighted, the weights are determined empirically
        let output_idx = block_index * partitionCount + p;
        let outputPtr = &encoding_choice_errors[output_idx];

        (*outputPtr).rgb_scale_error = (samec_err - uncorr_err) * 0.7;
        (*outputPtr).rgb_luma_error  = (rgb_luma_err - uncorr_err) * 1.5;
        (*outputPtr).luminance_error = (luma_err - uncorr_err) * 3.0;
        (*outputPtr).alpha_drop_error = alpha_drop_err * 3.0;
        (*outputPtr).can_offset_encode = can_offset_encode;
        (*outputPtr).can_blue_contract = can_blue_contract;
    }
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_PARTITIONS: u32 = 4u;
const BLOCK_MAX_TEXELS: u32 = 144u;

const NUM_QUANT_LEVELS = 21u;
const NUM_INT_COUNTS = 4u; //8,6,4,2
const ERROR_CALC_DEFAULT = 1e37f;

//error that is generally expected for quantization level
const BASELINE_QUANT_ERROR = array<f32, 17> ( //size is 21 - 4 (QUANT_6)
	(65536.0f * 65536.0f / 18.0f) / (5 * 5),
	(65536.0f * 65536.0f / 18.0f) / (7 * 7),
	(65536.0f * 65536.0f / 18.0f) / (9 * 9),
	(65536.0f * 65536.0f / 18.0f) / (11 * 11),
	(65536.0f * 65536.0f / 18.0f) / (15 * 15),
	(65536.0f * 65536.0f / 18.0f) / (19 * 19),
	(65536.0f * 65536.0f / 18.0f) / (23 * 23),
	(65536.0f * 65536.0f / 18.0f) / (31 * 31),
	(65536.0f * 65536.0f / 18.0f) / (39 * 39),
	(65536.0f * 65536.0f / 18.0f) / (47 * 47),
	(65536.0f * 65536.0f / 18.0f) / (63 * 63),
	(65536.0f * 65536.0f / 18.0f) / (79 * 79),
	(65536.0f * 65536.0f / 18.0f) / (95 * 95),
	(65536.0f * 65536.0f / 18.0f) / (127 * 127),
	(65536.0f * 65536.0f / 18.0f) / (159 * 159),
	(65536.0f * 65536.0f / 18.0f) / (191 * 191),
	(65536.0f * 65536.0f / 18.0f) / (255 * 255),
);

//ASTC endpoint formats
const FMT_LUMINANCE = 0u;
const FMT_LUMINANCE_DELTA = 1u;
const FMT_HDR_LUMINANCE_LARGE_RANGE = 2u;
const FMT_HDR_LUMINANCE_SMALL_RANGE = 3u;
const FMT_LUMINANCE_ALPHA = 4u;
const FMT_LUMINANCE_ALPHA_DELTA = 5u;
const FMT_RGB_SCALE = 6u;
const FMT_HDR_RGB_SCALE = 7u;
const FMT_RGB = 8u;
const FMT_RGB_DELTA = 9u;
const FMT_RGB_SCALE_ALPHA = 10u;
const FMT_HDR_RGB = 11u;
const FMT_RGBA = 12u;
const FMT_RGBA_DELTA = 13u;
const FMT_HDR_RGB_LDR_ALPHA = 14u;
const FMT_HDR_RGBA = 15u;



struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct IdealEndpointsAndWeights {
    partitions: array<IdealEndpointsAndWeightsPartition, 4>,
    weights: array<f32, BLOCK_MAX_TEXELS>,

    weight_error_scale: array<f32, BLOCK_MAX_TEXELS>,

    is_constant_weight_error_scale : u32,
    min_weight_cuttof : f32,
    _padding1 : u32,
    _padding2 : u32,
};

struct EncodingChoiceErrors {
    rgb_scale_error: f32,
    rgb_luma_error: f32,
    luminance_error: f32,
    alpha_drop_error: f32,

    can_offset_encode: u32,
    can_blue_contract: u32,

    _padding1: u32,
    _padding2: u32,
}


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> inputBlocks: array<InputBlock>;
@group(0) @binding(2) var<storage, read> ideal_endpoints_and_weights: array<IdealEndpointsAndWeights>;
@group(0) @binding(3) var<storage, read> encoding_choice_errors: array<EncodingChoiceErrors>;

@group(0) @binding(4) var<storage, read_write> output_best_error: array<f32>;
@group(0) @binding(5) var<storage, read_write> output_format_of_choice: array<u32>;



// Pre-calculated values, one for each partition in the block.
var<workgroup> part_rgb_range_error: array<f32, 4>;
var<workgroup> part_alpha_range_error: array<f32, 4>;
var<workgroup> part_base_quant_error_rgb: array<f32, 4>;
var<workgroup> part_base_quant_error_a: array<f32, 4>;
var<workgroup> part_error_scale_bc_rgba: array<f32, 4>;
var<workgroup> part_error_scale_oe_rgba: array<f32, 4>;
var<workgroup> part_error_scale_bc_rgb: array<f32, 4>;
var<workgroup> part_error_scale_oe_rgb: array<f32, 4>;


@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {
    let block_idx = group_id.x;
    let partition_count = uniforms.partition_count;

    //precomputation
    if(local_idx < partition_count) {
        let p = local_idx;
        let part_global_idx = block_idx * uniforms.partition_count + p;

        let ep0 = ideal_endpoints_and_weights[block_idx].partitions[p].endpoint0;
        let ep1 = ideal_endpoints_and_weights[block_idx].partitions[p].endpoint1;

        let eci = encoding_choice_errors[part_global_idx];
        let partition_size = f32(inputBlocks[block_idx].partition_pixel_counts[p]);

        //Calculate range error (endpoints going out of [0, 65535] range)
        let offset = vec4<f32>(65535.0);
        let ep0_err_high = max(ep0 - offset, vec4<f32>(0.0));
        let ep1_err_high = max(ep1 - offset, vec4<f32>(0.0));
        let ep0_err_low = min(ep0, vec4<f32>(0.0));
        let ep1_err_low = min(ep1, vec4<f32>(0.0));

        let sum_range_err = (ep0_err_low * ep0_err_low) + (ep1_err_low * ep1_err_low) + (ep0_err_high * ep0_err_high) + (ep1_err_high * ep1_err_high);
        
        part_rgb_range_error[p] = dot(sum_range_err.xyz, uniforms.channel_weights.xyz) * 0.5 * partition_size;
        part_alpha_range_error[p] = sum_range_err.w * uniforms.channel_weights.w * 0.5 * partition_size;

        //precompute quantization errors
        let error_weight = uniforms.channel_weights;
        part_base_quant_error_rgb[p] = (error_weight.x + error_weight.y + error_weight.z) * partition_size;
        part_base_quant_error_a[p] = error_weight.w * partition_size;

        //precompute error scales for offset encoding and blue channel contract
        part_error_scale_bc_rgba[p] = select(1.0, 0.625, eci.can_blue_contract == 1u);
        part_error_scale_oe_rgba[p] = select(1.0, 0.5, eci.can_offset_encode == 1u);
        part_error_scale_bc_rgb[p] = select(1.0, 0.5, eci.can_blue_contract == 1u);
        part_error_scale_oe_rgb[p] = select(1.0, 0.25, eci.can_offset_encode == 1u);


        //initialize low precision quantizazion modes (QUANT_2, QUANT_3, QUANT_4, QUANT_5)
        for(var i = 0u; i < 4; i += 1u) {
            let base_index = (part_global_idx * NUM_QUANT_LEVELS + i) * NUM_INT_COUNTS;

            output_best_error[base_index + 3u] = ERROR_CALC_DEFAULT;
            output_best_error[base_index + 2u] = ERROR_CALC_DEFAULT;
            output_best_error[base_index + 1u] = ERROR_CALC_DEFAULT;
            output_best_error[base_index + 0u] = ERROR_CALC_DEFAULT;

            output_format_of_choice[base_index + 3u] = FMT_RGBA; //8 integers
            output_format_of_choice[base_index + 2u] = FMT_RGB; //6 integers
            output_format_of_choice[base_index + 1u] = FMT_RGB_SCALE; //4 integers
            output_format_of_choice[base_index + 0u] = FMT_LUMINANCE; //2 integers
        }
    }

    workgroupBarrier();

    //Pick the best endpoint encoding for every quantization level, for every integer count
    //from QUANT_6 to QUANT_256
    for(var i = local_idx; i < 17; i += WORKGROUP_SIZE) {
        let quant_idx = i + 4u; //start at QUANT_6

        for(var p = 0u; p < partition_count; p += 1u) {
			let part_global_idx = block_idx * uniforms.partition_count + p;
            let eci = encoding_choice_errors[part_global_idx];

            //get precomputed values from shared memory
            let rgb_range_err = part_rgb_range_error[p];
            let alpha_range_err = part_alpha_range_error[p];
            let base_err_rgb = part_base_quant_error_rgb[p];
            let base_err_a = part_base_quant_error_a[p];
			
            var oe_rgba = part_error_scale_oe_rgba[p];
            var oe_rgb = part_error_scale_oe_rgb[p];
            if (quant_idx >= 19) { // QUANT_192 and up
                oe_rgba = 1.0;
                oe_rgb = 1.0;
            }

            let base_quant_err = BASELINE_QUANT_ERROR[i];
            let quant_err_rgb = base_err_rgb * base_quant_err;
            let quant_err_rgba = (base_err_rgb + base_err_a) * base_quant_err;


            var best_err: array<f32, NUM_INT_COUNTS>;
            var format_choice: array<u32, NUM_INT_COUNTS>;

            //8 integers (RGBA)
            best_err[3] = quant_err_rgba * part_error_scale_bc_rgba[p] * oe_rgba + rgb_range_err + alpha_range_err;
            format_choice[3] = FMT_RGBA;

            //6 integers (RGB vs RGBS+A)
            let full_ldr_rgb_err = quant_err_rgb * part_error_scale_bc_rgb[p] * oe_rgb + rgb_range_err + eci.alpha_drop_error;
            let rgbs_alpha_err = quant_err_rgba + eci.rgb_scale_error + rgb_range_err + alpha_range_err;
            if (rgbs_alpha_err < full_ldr_rgb_err) {
                best_err[2] = rgbs_alpha_err;
                format_choice[2] = FMT_RGB_SCALE_ALPHA;
            } else {
                best_err[2] = full_ldr_rgb_err;
                format_choice[2] = FMT_RGB;
            }

            // 4 integers (RGBS vs LA+LA)
            let ldr_rgbs_err = quant_err_rgb + rgb_range_err + eci.alpha_drop_error + eci.rgb_scale_error;
            let lum_alpha_err = quant_err_rgba + rgb_range_err + alpha_range_err + eci.luminance_error;
            if (ldr_rgbs_err < lum_alpha_err) {
                best_err[1] = ldr_rgbs_err;
                format_choice[1] = FMT_RGB_SCALE;
            } else {
                best_err[1] = lum_alpha_err;
                format_choice[1] = FMT_LUMINANCE_ALPHA;
            }

            // 2 integers (Luminance)
            best_err[0] = quant_err_rgb + rgb_range_err + eci.alpha_drop_error + eci.luminance_error;
            format_choice[0] = FMT_LUMINANCE;


            //write results for this partition & quantization level
            let base_index = (part_global_idx * NUM_QUANT_LEVELS + quant_idx) * NUM_INT_COUNTS;
            for (var j = 0u; j < 4u; j = j + 1u) {
                output_best_error[base_index + j] = best_err[j];
                output_format_of_choice[base_index + j] = format_choice[j];
            }
        }
    }

}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_PARTITIONS: u32 = 4u;
const NUM_QUANT_LEVELS: u32 = 21u;
const NUM_INT_COUNTS: u32 = 4u;  // 2, 4, 6, 8 integers
const NUM_COMBINED_INT_COUNTS: u32 = 7u; // Total integers can be 2+2=4 up to 8+8=16. Indices 0..6 for i+j.
const ERROR_CALC_DEFAULT: f32 = 1e37;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct CombinedEndpointFormats {
	error: f32,

    _padding0: u32,
    _padding1: u32,
    _padding2: u32,

    formats: vec4<u32>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> color_error_table: array<f32>;
@group(0) @binding(2) var<storage, read> format_choice_table: array<u32>;

@group(0) @binding(3) var<storage, read_write> combined_endpoint_formats: array<CombinedEndpointFormats>;

@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {
    let block_idx = group_id.x;

    //Initialize output buffer to highest possible error
    let total_slots_to_init = NUM_QUANT_LEVELS * NUM_COMBINED_INT_COUNTS;
    let output_base_idx = block_idx * NUM_QUANT_LEVELS * NUM_COMBINED_INT_COUNTS;

    for(var i = local_idx; i < total_slots_to_init; i += WORKGROUP_SIZE) {
        let out_ptr = &combined_endpoint_formats[output_base_idx + i];
        (*out_ptr).error = ERROR_CALC_DEFAULT;
    }

    workgroupBarrier();

    //For every quant level, find the best color format combinatoin for every integer count
    let p0_error_base = (block_idx * uniforms.partition_count + 0u) * NUM_QUANT_LEVELS * NUM_INT_COUNTS;
    let p1_error_base = (block_idx * uniforms.partition_count + 1u) * NUM_QUANT_LEVELS * NUM_INT_COUNTS;

    if(local_idx < (NUM_QUANT_LEVELS - 4)) { //QUANT_6 = 4
        let quant_level = local_idx + 4u; //Start from QUANT_6

        // Loop through the 4 integer count choices for partition 0
        for (var i = 0u; i < 4u; i = i + 1u) {
            // Loop through the 4 integer count choices for partition 1
            for (var j = 0u; j < 4u; j = j + 1u) {

                //Number of integers used for each partition can only differ by one step
                let low2 = min(i, j);
                let high2 = max(i, j);
                if (high2 - low2 > 1u) {
					continue; // Skip if the difference is more than 1
				}

                let total_int_count = i + j;

                // Read the pre-computed errors for this pairing.
                let error0 = color_error_table[p0_error_base + quant_level * NUM_INT_COUNTS + i];
                let error1 = color_error_table[p1_error_base + quant_level * NUM_INT_COUNTS + j];
                let total_error = min(error0 + error1, 1e10); // Clamp to avoid huge values

                // Check if this pairing is the new best for this total_int_count.
                let out_idx = output_base_idx + quant_level * NUM_COMBINED_INT_COUNTS + total_int_count;
                let out_ptr = &combined_endpoint_formats[out_idx];

                if (total_error < (*out_ptr).error) {
                    let format0 = format_choice_table[p0_error_base + quant_level * NUM_INT_COUNTS + i];
                    let format1 = format_choice_table[p1_error_base + quant_level * NUM_INT_COUNTS + j];
                    (*out_ptr).error = total_error;
                    (*out_ptr).formats = vec4<u32>(format0, format1, 0, 0);
                }
            }
        }
    }
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_PARTITIONS: u32 = 4u;
const NUM_QUANT_LEVELS: u32 = 21u;
const NUM_INT_COUNTS: u32 = 4u;  // 2, 4, 6, 8 integers
const NUM_COMBINED_INT_COUNTS: u32 = 10u;
const ERROR_CALC_DEFAULT: f32 = 1e37;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct CombinedEndpointFormats {
	error: f32,

    _padding0: u32,
    _padding1: u32,
    _padding2: u32,

    formats: vec4<u32>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> color_error_table: array<f32>;
@group(0) @binding(2) var<storage, read> format_choice_table: array<u32>;

@group(0) @binding(3) var<storage, read_write> combined_endpoint_formats: array<CombinedEndpointFormats>;

@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {
    let block_idx = group_id.x;

    //Initialize output buffer to highest possible error
    let total_slots_to_init = NUM_QUANT_LEVELS * NUM_COMBINED_INT_COUNTS;
    let output_base_idx = block_idx * NUM_QUANT_LEVELS * NUM_COMBINED_INT_COUNTS;

    for(var i = local_idx; i < total_slots_to_init; i += WORKGROUP_SIZE) {
        let out_ptr = &combined_endpoint_formats[output_base_idx + i];
        (*out_ptr).error = ERROR_CALC_DEFAULT;
    }

    workgroupBarrier();

    //For every quant level, find the best color format combinatoin for every integer count
    let p0_error_base = (block_idx * uniforms.partition_count + 0u) * NUM_QUANT_LEVELS * NUM_INT_COUNTS;
    let p1_error_base = (block_idx * uniforms.partition_count + 1u) * NUM_QUANT_LEVELS * NUM_INT_COUNTS;
    let p2_error_base = (block_idx * uniforms.partition_count + 2u) * NUM_QUANT_LEVELS * NUM_INT_COUNTS;

    if(local_idx < (NUM_QUANT_LEVELS - 4)) { //QUANT_6 = 4
        let quant_level = local_idx + 4u; //Start from QUANT_6

        // Loop through the 4 integer count choices for partition 0
        for (var i = 0u; i < 4u; i = i + 1u) {
            // Loop through the 4 integer count choices for partition 1
            for (var j = 0u; j < 4u; j = j + 1u) {

                //Number of integers used for each partition can only differ by one step
                let low2 = min(i, j);
                let high2 = max(i, j);
                if (high2 - low2 > 1u) {
					continue; // Skip if the difference is more than 1
				}

                // Loop through the 4 integer count choices for partition 2
                for (var k = 0u; k < 4u; k = k + 1u) {

                    let low3 = min(k, low2);
                    let high3 = max(k, high2);
                    if (high3 - low3 > 1u) {
                        continue;
                    }

                    let total_int_count = i + j + k;

                    // Read the pre-computed errors for this pairing.
                    let error0 = color_error_table[p0_error_base + quant_level * NUM_INT_COUNTS + i];
                    let error1 = color_error_table[p1_error_base + quant_level * NUM_INT_COUNTS + j];
                    let error2 = color_error_table[p2_error_base + quant_level * NUM_INT_COUNTS + k];
                    let total_error = min(error0 + error1 + error2, 1e10); // Clamp to avoid huge values

                    // Check if this pairing is the new best for this total_int_count.
                    let out_idx = output_base_idx + quant_level * NUM_COMBINED_INT_COUNTS + total_int_count;
                    let out_ptr = &combined_endpoint_formats[out_idx];

                    if (total_error < (*out_ptr).error) {
                        let format0 = format_choice_table[p0_error_base + quant_level * NUM_INT_COUNTS + i];
                        let format1 = format_choice_table[p1_error_base + quant_level * NUM_INT_COUNTS + j];
                        let format2 = format_choice_table[p2_error_base + quant_level * NUM_INT_COUNTS + k];
                        (*out_ptr).error = total_error;
                        (*out_ptr).formats = vec4<u32>(format0, format1, format2, 0);
                    }            
                }
            }
        }
    }
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_PARTITIONS: u32 = 4u;
const NUM_QUANT_LEVELS: u32 = 21u;
const NUM_INT_COUNTS: u32 = 4u;  // 2, 4, 6, 8 integers
const NUM_COMBINED_INT_COUNTS: u32 = 13u;
const ERROR_CALC_DEFAULT: f32 = 1e37;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct CombinedEndpointFormats {
	error: f32,

    _padding0: u32,
    _padding1: u32,
    _padding2: u32,

    formats: vec4<u32>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> color_error_table: array<f32>;
@group(0) @binding(2) var<storage, read> format_choice_table: array<u32>;

@group(0) @binding(3) var<storage, read_write> combined_endpoint_formats: array<CombinedEndpointFormats>;

@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {
    let block_idx = group_id.x;

    //Initialize output buffer to highest possible error
    let total_slots_to_init = NUM_QUANT_LEVELS * NUM_COMBINED_INT_COUNTS;
    let output_base_idx = block_idx * NUM_QUANT_LEVELS * NUM_COMBINED_INT_COUNTS;

    for(var i = local_idx; i < total_slots_to_init; i += WORKGROUP_SIZE) {
        let out_ptr = &combined_endpoint_formats[output_base_idx + i];
        (*out_ptr).error = ERROR_CALC_DEFAULT;
    }

    workgroupBarrier();

    //For every quant level, find the best color format combinatoin for every integer count
    let p0_error_base = (block_idx * uniforms.partition_count + 0u) * NUM_QUANT_LEVELS * NUM_INT_COUNTS;
    let p1_error_base = (block_idx * uniforms.partition_count + 1u) * NUM_QUANT_LEVELS * NUM_INT_COUNTS;
    let p2_error_base = (block_idx * uniforms.partition_count + 2u) * NUM_QUANT_LEVELS * NUM_INT_COUNTS;
    let p3_error_base = (block_idx * uniforms.partition_count + 3u) * NUM_QUANT_LEVELS * NUM_INT_COUNTS;

    if(local_idx < (NUM_QUANT_LEVELS - 4)) { //QUANT_6 = 4
        let quant_level = local_idx + 4u; //Start from QUANT_6

        // Loop through the 4 integer count choices for partition 0
        for (var i = 0u; i < 4u; i = i + 1u) {
            // Loop through the 4 integer count choices for partition 1
            for (var j = 0u; j < 4u; j = j + 1u) {

                //Number of integers used for each partition can only differ by one step
                let low2 = min(i, j);
                let high2 = max(i, j);
                if (high2 - low2 > 1u) {
					continue; // Skip if the difference is more than 1
				}

                // Loop through the 4 integer count choices for partition 2
                for (var k = 0u; k < 4u; k = k + 1u) {

                    let low3 = min(k, low2);
                    let high3 = max(k, high2);
                    if (high3 - low3 > 1u) {
                        continue;
                    }

                    // Loop through the 4 integer count choices for partition 2
                    for (var l = 0u; l < 4u; l = l + 1u) {

                        let low4 = min(l, low3);
                        let high4 = max(l, high3);
                        if (high4 - low4 > 1u) {
                            continue;
                        }

                        let total_int_count = i + j + k + l;

                        // Read the pre-computed errors for this pairing.
                        let error0 = color_error_table[p0_error_base + quant_level * NUM_INT_COUNTS + i];
                        let error1 = color_error_table[p1_error_base + quant_level * NUM_INT_COUNTS + j];
                        let error2 = color_error_table[p2_error_base + quant_level * NUM_INT_COUNTS + k];
                        let error3 = color_error_table[p3_error_base + quant_level * NUM_INT_COUNTS + l];
                        let total_error = min(error0 + error1 + error2 + error3, 1e10); // Clamp to avoid huge values

                        // Check if this pairing is the new best for this total_int_count.
                        let out_idx = output_base_idx + quant_level * NUM_COMBINED_INT_COUNTS + total_int_count;
                        let out_ptr = &combined_endpoint_formats[out_idx];

                        if (total_error < (*out_ptr).error) {
                            let format0 = format_choice_table[p0_error_base + quant_level * NUM_INT_COUNTS + i];
                            let format1 = format_choice_table[p1_error_base + quant_level * NUM_INT_COUNTS + j];
                            let format2 = format_choice_table[p2_error_base + quant_level * NUM_INT_COUNTS + k];
                            let format3 = format_choice_table[p3_error_base + quant_level * NUM_INT_COUNTS + l];
                            (*out_ptr).error = total_error;
                            (*out_ptr).formats = vec4<u32>(format0, format1, format2, format3);
                        }
                    }            
                }
            }
        }
    }
}const WORKGROUP_SIZE: u32 = 1u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const NUM_QUANT_LEVELS: u32 = 21u;
const NUM_INT_COUNTS: u32 = 4u; // The 4 integer counts (2, 4, 6, 8 ints)
const MAX_BITS: u32 = 128u;
const BLOCK_MAX_PARTITIONS: u32 = 4u;
const ERROR_CALC_DEFAULT: f32 = 1e37;

//precomputed quantization levels for integer count and avalible bits
//-1 if integer count cannot fit in the available bits
//the table is flattened, indexed by: integer_count * MAX_BITS + bit_count
const QUANT_MODE_TABLE = array<i32, 1280>(
    //0 integers
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    //2 integers
    -1, -1,  0,  0,  2,  3,  5,  6,  8,  9, 11, 12, 14, 15, 17, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //4 integers
    -1, -1, -1, -1,  0,  0,  0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //6 integers
    -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,  8,  8,  9,  9, 10, 10, 11, 11,
    12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //8 integers
    -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  1,  1,  1,  2,  2,  2,  3,  3,  4,  4,  4,  5,  5,  5,  6,  6,  7,  7,  7,
     8,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //10 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  4,  4,  4,  4,  5,  5,
     5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14,
    15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //12 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
     4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11,
    12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //14 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  2,  2,  2,
     2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  9,  9,  9,
     9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16,
    16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //16 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,
     2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,
    8,  8,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10,  11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13,
    14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19,
    //18 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,
     1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,
     6,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,
    12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17
);

//ASTC endpoint formats
const FMT_LUMINANCE = 0u;
const FMT_LUMINANCE_DELTA = 1u;
const FMT_HDR_LUMINANCE_LARGE_RANGE = 2u;
const FMT_HDR_LUMINANCE_SMALL_RANGE = 3u;
const FMT_LUMINANCE_ALPHA = 4u;
const FMT_LUMINANCE_ALPHA_DELTA = 5u;
const FMT_RGB_SCALE = 6u;
const FMT_HDR_RGB_SCALE = 7u;
const FMT_RGB = 8u;
const FMT_RGB_DELTA = 9u;
const FMT_RGB_SCALE_ALPHA = 10u;
const FMT_HDR_RGB = 11u;
const FMT_RGBA = 12u;
const FMT_RGBA_DELTA = 13u;
const FMT_HDR_RGB_LDR_ALPHA = 14u;
const FMT_HDR_RGBA = 15u;



struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct PackedBlockModeLookup {
    block_mode_index: u32,
    decimation_mode_lookup_idx: u32, //index of corresponding decimation mode in the valid decimation modes buffer

    _padding1: u32,
    _padding2: u32,
};

struct QuantizationResult {
    error: f32,
    bitcount: i32,

    _padding1: u32,
    _padding2: u32,

    quantized_weights: array<u32, (BLOCK_MAX_WEIGHTS/4)>,
};

struct ColorCombinationResult {
    total_error: f32,
    best_quant_level: u32,
    best_quant_level_mod: u32,

    _padding1: u32,

    best_ep_formats: vec4<u32>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_block_modes: array<PackedBlockModeLookup>;
@group(0) @binding(2) var<storage, read> quantization_results: array<QuantizationResult>;
@group(0) @binding(3) var<storage, read> color_error_table: array<f32>;
@group(0) @binding(4) var<storage, read> format_choice_table: array<u32>;

@group(0) @binding(5) var<storage, read_write> output_color_combination_results: array<ColorCombinationResult>;

@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {

    let block_index = global_id.x;
    let bm_lookup_idx = global_id.y;
    let block_mode_index = valid_block_modes[bm_lookup_idx].block_mode_index;

    let num_valid_bms = uniforms.valid_block_mode_count;
    let block_mode_trial_index = block_index * num_valid_bms + bm_lookup_idx;


    let quant_result = quantization_results[block_mode_trial_index];
    let weight_error = quant_result.error;
    let bits_avalible = quant_result.bitcount;


    //skip if error is already to high
    if(weight_error >= ERROR_CALC_DEFAULT) {
        let out_ptr = &output_color_combination_results[block_mode_trial_index];
        (*out_ptr).total_error = ERROR_CALC_DEFAULT;
        return;
    }

    var best_integer_count_idx = 0u;
    var best_integer_count_error = ERROR_CALC_DEFAULT;

    let integer_count_error_idx_base = (block_index * uniforms.partition_count + 0u) * NUM_QUANT_LEVELS;

    //Loop through 4 integer counts (2,4,6,8)
    for(var int_count_idx = 1u; int_count_idx <= 4u; int_count_idx = int_count_idx + 1u) {
        
        let quant_table_idx = (int_count_idx * MAX_BITS) + u32(bits_avalible);
        let quant_level = QUANT_MODE_TABLE[quant_table_idx];

        //We don't have enough bits to represent a given endpoint format
        if(quant_level < 4) { //QUANT_6 = 4
			continue;
		}

        let integer_count_error_idx = (integer_count_error_idx_base + u32(quant_level)) * NUM_INT_COUNTS + int_count_idx - 1u;
        let integer_count_error = color_error_table[integer_count_error_idx];

        if(integer_count_error < best_integer_count_error) {
			best_integer_count_error = integer_count_error;
			best_integer_count_idx = int_count_idx;
		}
    }

    let final_ql_index = (best_integer_count_idx * MAX_BITS) + u32(bits_avalible);
    let final_quant_level = QUANT_MODE_TABLE[final_ql_index];

    var best_ep_format = FMT_LUMINANCE;
    if(final_quant_level >= 4) {
        let format_choice_idx = ((block_index * uniforms.partition_count + 0u) * NUM_QUANT_LEVELS + u32(final_quant_level)) * NUM_INT_COUNTS + best_integer_count_idx - 1u;
        best_ep_format = format_choice_table[format_choice_idx];
    }


    //Finalization
    let total_error = best_integer_count_error + weight_error;

    let out_ptr = &output_color_combination_results[block_mode_trial_index];
    (*out_ptr).total_error = total_error;
    (*out_ptr).best_quant_level = u32(final_quant_level);
    (*out_ptr).best_quant_level_mod = u32(final_quant_level); // For 1-partition, these are the same

    (*out_ptr).best_ep_formats = vec4<u32>(0u); //Init to default values
    (*out_ptr).best_ep_formats[0] = best_ep_format;
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const NUM_QUANT_LEVELS: u32 = 21u;
const NUM_COMBINED_INT_COUNTS: u32 = 7u; // Total integers can be 2+2=4 up to 8+8=16. Indices 0..6 for i+j.
const MAX_BITS: u32 = 128u;
const ERROR_CALC_DEFAULT: f32 = 1e37;

//precomputed quantization levels for integer count and avalible bits
//-1 if integer count cannot fit in the available bits
//the table is flattened, indexed by: integer_count * MAX_BITS + bit_count
const QUANT_MODE_TABLE = array<i32, 1280>(
    //0 integers
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    //2 integers
    -1, -1,  0,  0,  2,  3,  5,  6,  8,  9, 11, 12, 14, 15, 17, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //4 integers
    -1, -1, -1, -1,  0,  0,  0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //6 integers
    -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,  8,  8,  9,  9, 10, 10, 11, 11,
    12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //8 integers
    -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  1,  1,  1,  2,  2,  2,  3,  3,  4,  4,  4,  5,  5,  5,  6,  6,  7,  7,  7,
     8,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //10 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  4,  4,  4,  4,  5,  5,
     5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14,
    15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //12 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
     4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11,
    12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //14 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  2,  2,  2,
     2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  9,  9,  9,
     9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16,
    16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //16 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,
     2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,
    8,  8,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10,  11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13,
    14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19,
    //18 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,
     1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,
     6,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,
    12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17
);

//ASTC endpoint formats
const FMT_LUMINANCE = 0u;
const FMT_LUMINANCE_DELTA = 1u;
const FMT_HDR_LUMINANCE_LARGE_RANGE = 2u;
const FMT_HDR_LUMINANCE_SMALL_RANGE = 3u;
const FMT_LUMINANCE_ALPHA = 4u;
const FMT_LUMINANCE_ALPHA_DELTA = 5u;
const FMT_RGB_SCALE = 6u;
const FMT_HDR_RGB_SCALE = 7u;
const FMT_RGB = 8u;
const FMT_RGB_DELTA = 9u;
const FMT_RGB_SCALE_ALPHA = 10u;
const FMT_HDR_RGB = 11u;
const FMT_RGBA = 12u;
const FMT_RGBA_DELTA = 13u;
const FMT_HDR_RGB_LDR_ALPHA = 14u;
const FMT_HDR_RGBA = 15u;




struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct PackedBlockModeLookup {
    block_mode_index: u32,
    decimation_mode_lookup_idx: u32, //index of corresponding decimation mode in the valid decimation modes buffer

    _padding1: u32,
    _padding2: u32,
};

struct QuantizationResult {
    error: f32,
    bitcount: i32,

    _padding1: u32,
    _padding2: u32,

    quantized_weights: array<u32, (BLOCK_MAX_WEIGHTS/4)>,
};

struct CombinedEndpointFormats {
	error: f32,

    _padding0: u32,
    _padding1: u32,
    _padding2: u32,

    formats: vec4<u32>,
};

struct ColorCombinationResult {
    total_error: f32,
    best_quant_level: u32,
    best_quant_level_mod: u32,

    _padding1: u32,

    best_ep_formats: vec4<u32>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_block_modes: array<PackedBlockModeLookup>;
@group(0) @binding(2) var<storage, read> quantization_results: array<QuantizationResult>;
@group(0) @binding(3) var<storage, read> combined_endpoint_formats: array<CombinedEndpointFormats>;

@group(0) @binding(4) var<storage, read_write> output_color_combination_results: array<ColorCombinationResult>;

@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {

    let block_index = global_id.x;
    let bm_lookup_idx = global_id.y;
    let block_mode_index = valid_block_modes[bm_lookup_idx].block_mode_index;

    let num_valid_bms = uniforms.valid_block_mode_count;
    let block_mode_trial_index = block_index * num_valid_bms + bm_lookup_idx;

    let quant_result = quantization_results[block_mode_trial_index];
    let weight_error = quant_result.error;
    let bits_avalible = quant_result.bitcount;


    //Skip if error is already to high
    if(weight_error >= ERROR_CALC_DEFAULT) {
        let out_ptr = &output_color_combination_results[block_mode_trial_index];
        (*out_ptr).total_error = ERROR_CALC_DEFAULT;
        return;
    }

    var best_total_int_count_idx = 0u;
    var best_color_error = ERROR_CALC_DEFAULT;

    let combined_error_base = block_index * NUM_QUANT_LEVELS * NUM_COMBINED_INT_COUNTS;

    // Loop through the 7 possible total integer counts (from 2+2=4 to 8+8=16)
    for (var int_count_idx = 2u; int_count_idx <= 8u; int_count_idx = int_count_idx + 1u) {

        let quant_table_idx = (int_count_idx * MAX_BITS) + u32(bits_avalible);
        let quant_level = QUANT_MODE_TABLE[quant_table_idx];

        //We don't have enough bits to represent a given endpoint format
        if(quant_level < 4) { //QUANT_6 = 4
			break;
		}

        let combined_error_idx = combined_error_base + u32(quant_level) * NUM_COMBINED_INT_COUNTS + int_count_idx - 2u;
        let combined_error = combined_endpoint_formats[combined_error_idx].error;
        if (combined_error < best_color_error) {
            best_color_error = combined_error;
            best_total_int_count_idx = int_count_idx;
        }
    }

    let final_quant_level = QUANT_MODE_TABLE[(best_total_int_count_idx * MAX_BITS) + u32(bits_avalible)];
    let final_quant_level_mod = QUANT_MODE_TABLE[(best_total_int_count_idx * MAX_BITS) + u32(bits_avalible) + 2u];

    var final_best_formats = vec4<u32>(0u); //default formats
    if (final_quant_level >= 4) { //QUANT_6 = 4
		let combined_error_idx = combined_error_base + u32(final_quant_level) * NUM_COMBINED_INT_COUNTS + best_total_int_count_idx - 2u;
		final_best_formats = combined_endpoint_formats[combined_error_idx].formats;
	}

    //Finalization
    let total_error = best_color_error + weight_error;

    let out_ptr = &output_color_combination_results[block_mode_trial_index];
    (*out_ptr).total_error = total_error;
    (*out_ptr).best_quant_level = u32(final_quant_level);
    (*out_ptr).best_quant_level_mod = u32(final_quant_level_mod);
    (*out_ptr).best_ep_formats = final_best_formats;
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const NUM_QUANT_LEVELS: u32 = 21u;
const NUM_COMBINED_INT_COUNTS: u32 = 10u;
const MAX_BITS: u32 = 128u;
const ERROR_CALC_DEFAULT: f32 = 1e37;

//precomputed quantization levels for integer count and avalible bits
//-1 if integer count cannot fit in the available bits
//the table is flattened, indexed by: integer_count * MAX_BITS + bit_count
const QUANT_MODE_TABLE = array<i32, 1280>(
    //0 integers
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    //2 integers
    -1, -1,  0,  0,  2,  3,  5,  6,  8,  9, 11, 12, 14, 15, 17, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //4 integers
    -1, -1, -1, -1,  0,  0,  0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //6 integers
    -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,  8,  8,  9,  9, 10, 10, 11, 11,
    12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //8 integers
    -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  1,  1,  1,  2,  2,  2,  3,  3,  4,  4,  4,  5,  5,  5,  6,  6,  7,  7,  7,
     8,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //10 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  4,  4,  4,  4,  5,  5,
     5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14,
    15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //12 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
     4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11,
    12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //14 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  2,  2,  2,
     2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  9,  9,  9,
     9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16,
    16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //16 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,
     2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,
    8,  8,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10,  11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13,
    14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19,
    //18 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,
     1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,
     6,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,
    12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17
);

//ASTC endpoint formats
const FMT_LUMINANCE = 0u;
const FMT_LUMINANCE_DELTA = 1u;
const FMT_HDR_LUMINANCE_LARGE_RANGE = 2u;
const FMT_HDR_LUMINANCE_SMALL_RANGE = 3u;
const FMT_LUMINANCE_ALPHA = 4u;
const FMT_LUMINANCE_ALPHA_DELTA = 5u;
const FMT_RGB_SCALE = 6u;
const FMT_HDR_RGB_SCALE = 7u;
const FMT_RGB = 8u;
const FMT_RGB_DELTA = 9u;
const FMT_RGB_SCALE_ALPHA = 10u;
const FMT_HDR_RGB = 11u;
const FMT_RGBA = 12u;
const FMT_RGBA_DELTA = 13u;
const FMT_HDR_RGB_LDR_ALPHA = 14u;
const FMT_HDR_RGBA = 15u;




struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct PackedBlockModeLookup {
    block_mode_index: u32,
    decimation_mode_lookup_idx: u32, //index of corresponding decimation mode in the valid decimation modes buffer

    _padding1: u32,
    _padding2: u32,
};

struct QuantizationResult {
    error: f32,
    bitcount: i32,

    _padding1: u32,
    _padding2: u32,

    quantized_weights: array<u32, (BLOCK_MAX_WEIGHTS/4)>,
};

struct CombinedEndpointFormats {
	error: f32,

    _padding0: u32,
    _padding1: u32,
    _padding2: u32,

    formats: vec4<u32>,
};

struct ColorCombinationResult {
    total_error: f32,
    best_quant_level: u32,
    best_quant_level_mod: u32,

    _padding1: u32,

    best_ep_formats: vec4<u32>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_block_modes: array<PackedBlockModeLookup>;
@group(0) @binding(2) var<storage, read> quantization_results: array<QuantizationResult>;
@group(0) @binding(3) var<storage, read> combined_endpoint_formats: array<CombinedEndpointFormats>;

@group(0) @binding(4) var<storage, read_write> output_color_combination_results: array<ColorCombinationResult>;

@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {

    let block_index = global_id.x;
    let bm_lookup_idx = global_id.y;
    let block_mode_index = valid_block_modes[bm_lookup_idx].block_mode_index;

    let num_valid_bms = uniforms.valid_block_mode_count;
    let block_mode_trial_index = block_index * num_valid_bms + bm_lookup_idx;

    let quant_result = quantization_results[block_mode_trial_index];
    let weight_error = quant_result.error;
    let bits_avalible = quant_result.bitcount;


    //Skip if error is already to high
    if(weight_error >= ERROR_CALC_DEFAULT) {
        let out_ptr = &output_color_combination_results[block_mode_trial_index];
        (*out_ptr).total_error = ERROR_CALC_DEFAULT;
        return;
    }

    var best_total_int_count_idx = 0u;
    var best_color_error = ERROR_CALC_DEFAULT;

    let combined_error_base = block_index * NUM_QUANT_LEVELS * NUM_COMBINED_INT_COUNTS;

    for (var int_count_idx = 3u; int_count_idx <= 9u; int_count_idx = int_count_idx + 1u) {

        let quant_table_idx = (int_count_idx * MAX_BITS) + u32(bits_avalible);
        let quant_level = QUANT_MODE_TABLE[quant_table_idx];

        //We don't have enough bits to represent a given endpoint format
        if(quant_level < 4) { //QUANT_6 = 4
			break;
		}

        let combined_error_idx = combined_error_base + u32(quant_level) * NUM_COMBINED_INT_COUNTS + int_count_idx - 3u;
        let combined_error = combined_endpoint_formats[combined_error_idx].error;
        if (combined_error < best_color_error) {
            best_color_error = combined_error;
            best_total_int_count_idx = int_count_idx;
        }
    }

    let final_quant_level = QUANT_MODE_TABLE[(best_total_int_count_idx * MAX_BITS) + u32(bits_avalible)];
    let final_quant_level_mod = QUANT_MODE_TABLE[(best_total_int_count_idx * MAX_BITS) + u32(bits_avalible) + 5u];

    var final_best_formats = vec4<u32>(0u); //default formats
    if (final_quant_level >= 4) { //QUANT_6 = 4
		let combined_error_idx = combined_error_base + u32(final_quant_level) * NUM_COMBINED_INT_COUNTS + best_total_int_count_idx - 3u;
		final_best_formats = combined_endpoint_formats[combined_error_idx].formats;
	}

    //Finalization
    let total_error = best_color_error + weight_error;

    let out_ptr = &output_color_combination_results[block_mode_trial_index];
    (*out_ptr).total_error = total_error;
    (*out_ptr).best_quant_level = u32(final_quant_level);
    (*out_ptr).best_quant_level_mod = u32(final_quant_level_mod);
    (*out_ptr).best_ep_formats = final_best_formats;
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const NUM_QUANT_LEVELS: u32 = 21u;
const NUM_COMBINED_INT_COUNTS: u32 = 13u;
const MAX_BITS: u32 = 128u;
const ERROR_CALC_DEFAULT: f32 = 1e37;

//precomputed quantization levels for integer count and avalible bits
//-1 if integer count cannot fit in the available bits
//the table is flattened, indexed by: integer_count * MAX_BITS + bit_count
const QUANT_MODE_TABLE = array<i32, 1280>(
    //0 integers
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    //2 integers
    -1, -1,  0,  0,  2,  3,  5,  6,  8,  9, 11, 12, 14, 15, 17, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //4 integers
    -1, -1, -1, -1,  0,  0,  0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //6 integers
    -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,  8,  8,  9,  9, 10, 10, 11, 11,
    12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //8 integers
    -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  1,  1,  1,  2,  2,  2,  3,  3,  4,  4,  4,  5,  5,  5,  6,  6,  7,  7,  7,
     8,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //10 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  4,  4,  4,  4,  5,  5,
     5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14,
    15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //12 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
     4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11,
    12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //14 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  2,  2,  2,
     2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  9,  9,  9,
     9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16,
    16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
    //16 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,
     2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,
    8,  8,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10,  11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13,
    14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19,
    //18 integers
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,
     1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,
     6,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,
    12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17
);

//ASTC endpoint formats
const FMT_LUMINANCE = 0u;
const FMT_LUMINANCE_DELTA = 1u;
const FMT_HDR_LUMINANCE_LARGE_RANGE = 2u;
const FMT_HDR_LUMINANCE_SMALL_RANGE = 3u;
const FMT_LUMINANCE_ALPHA = 4u;
const FMT_LUMINANCE_ALPHA_DELTA = 5u;
const FMT_RGB_SCALE = 6u;
const FMT_HDR_RGB_SCALE = 7u;
const FMT_RGB = 8u;
const FMT_RGB_DELTA = 9u;
const FMT_RGB_SCALE_ALPHA = 10u;
const FMT_HDR_RGB = 11u;
const FMT_RGBA = 12u;
const FMT_RGBA_DELTA = 13u;
const FMT_HDR_RGB_LDR_ALPHA = 14u;
const FMT_HDR_RGBA = 15u;



struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct PackedBlockModeLookup {
    block_mode_index: u32,
    decimation_mode_lookup_idx: u32, //index of corresponding decimation mode in the valid decimation modes buffer

    _padding1: u32,
    _padding2: u32,
};

struct QuantizationResult {
    error: f32,
    bitcount: i32,

    _padding1: u32,
    _padding2: u32,

    quantized_weights: array<u32, (BLOCK_MAX_WEIGHTS/4)>,
};

struct CombinedEndpointFormats {
	error: f32,

    _padding0: u32,
    _padding1: u32,
    _padding2: u32,

    formats: vec4<u32>,
};

struct ColorCombinationResult {
    total_error: f32,
    best_quant_level: u32,
    best_quant_level_mod: u32,

    _padding1: u32,

    best_ep_formats: vec4<u32>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_block_modes: array<PackedBlockModeLookup>;
@group(0) @binding(2) var<storage, read> quantization_results: array<QuantizationResult>;
@group(0) @binding(3) var<storage, read> combined_endpoint_formats: array<CombinedEndpointFormats>;

@group(0) @binding(4) var<storage, read_write> output_color_combination_results: array<ColorCombinationResult>;

@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {

    let block_index = global_id.x;
    let bm_lookup_idx = global_id.y;
    let block_mode_index = valid_block_modes[bm_lookup_idx].block_mode_index;

    let num_valid_bms = uniforms.valid_block_mode_count;
    let block_mode_trial_index = block_index * num_valid_bms + bm_lookup_idx;

    let quant_result = quantization_results[block_mode_trial_index];
    let weight_error = quant_result.error;
    let bits_avalible = quant_result.bitcount;


    //Skip if error is already to high
    if(weight_error >= ERROR_CALC_DEFAULT) {
        let out_ptr = &output_color_combination_results[block_mode_trial_index];
        (*out_ptr).total_error = ERROR_CALC_DEFAULT;
        return;
    }

    var best_total_int_count_idx = 0u;
    var best_color_error = ERROR_CALC_DEFAULT;

    let combined_error_base = block_index * NUM_QUANT_LEVELS * NUM_COMBINED_INT_COUNTS;

    for (var int_count_idx = 4u; int_count_idx <= 9u; int_count_idx = int_count_idx + 1u) {

        let quant_table_idx = (int_count_idx * MAX_BITS) + u32(bits_avalible);
        let quant_level = QUANT_MODE_TABLE[quant_table_idx];

        //We don't have enough bits to represent a given endpoint format
        if(quant_level < 4) { //QUANT_6 = 4
			break;
		}

        let combined_error_idx = combined_error_base + u32(quant_level) * NUM_COMBINED_INT_COUNTS + int_count_idx - 4u;
        let combined_error = combined_endpoint_formats[combined_error_idx].error;
        if (combined_error < best_color_error) {
            best_color_error = combined_error;
            best_total_int_count_idx = int_count_idx;
        }
    }

    let final_quant_level = QUANT_MODE_TABLE[(best_total_int_count_idx * MAX_BITS) + u32(bits_avalible)];
    let final_quant_level_mod = QUANT_MODE_TABLE[(best_total_int_count_idx * MAX_BITS) + u32(bits_avalible) + 8u];

    var final_best_formats = vec4<u32>(0u); //default formats
    if (final_quant_level >= 4) { //QUANT_6 = 4
		let combined_error_idx = combined_error_base + u32(final_quant_level) * NUM_COMBINED_INT_COUNTS + best_total_int_count_idx - 4u;
		final_best_formats = combined_endpoint_formats[combined_error_idx].formats;
	}

    //Finalization
    let total_error = best_color_error + weight_error;

    let out_ptr = &output_color_combination_results[block_mode_trial_index];
    (*out_ptr).total_error = total_error;
    (*out_ptr).best_quant_level = u32(final_quant_level);
    (*out_ptr).best_quant_level_mod = u32(final_quant_level_mod);
    (*out_ptr).best_ep_formats = final_best_formats;
}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;

const TUNE_MAX_TRIAL_CANDIDATES = 8u;
const ERROR_CALC_DEFAULT: f32 = 1e37;


struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct PackedBlockModeLookup {
    block_mode_index: u32,
    decimation_mode_lookup_idx: u32, //index of corresponding decimation mode in the valid decimation modes buffer

    _padding1: u32,
    _padding2: u32,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct IdealEndpointsAndWeights {
    partitions: array<IdealEndpointsAndWeightsPartition, 4>,
    weights: array<f32, BLOCK_MAX_TEXELS>,

    weight_error_scale: array<f32, BLOCK_MAX_TEXELS>,

    is_constant_weight_error_scale : u32,
    min_weight_cuttof : f32,
    _padding1 : u32,
    _padding2 : u32,
};

struct QuantizationResult {
    error: f32,
    bitcount: i32,

    _padding1: u32,
    _padding2: u32,

    quantized_weights: array<u32, (BLOCK_MAX_WEIGHTS/4)>,
};

struct ColorCombinationResult {
    total_error: f32,
    best_quant_level: u32,
    best_quant_level_mod: u32,

    _padding1: u32,

    best_ep_formats: vec4<u32>,
};

struct SortItem {
	error: f32,
	bm_trial_idx: u32,
};

struct FinalCandidate {
    block_mode_index: u32,
    block_mode_trial_index: u32,
    total_error: f32,
    quant_level: u32, // The original quant level
    quant_level_mod: u32,

    _padding1: u32,

	color_formats_matched: u32,
    final_quant_mode: u32, // The quant mode after checking the mod version

    formats: vec4<u32>,
    quantized_weights: array<u32, BLOCK_MAX_WEIGHTS>,
    candidate_partitions: array<IdealEndpointsAndWeightsPartition, 4>,

	final_formats: vec4<u32>,
	//8 integers per partition
    packed_color_values: array<u32, 32>,
};


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> valid_block_modes: array<PackedBlockModeLookup>;
@group(0) @binding(2) var<storage, read> ideal_endpoints_and_weights: array<IdealEndpointsAndWeights>;
@group(0) @binding(3) var<storage, read> quantization_results: array<QuantizationResult>;
@group(0) @binding(4) var<storage, read> color_combination_results: array<ColorCombinationResult>;

@group(0) @binding(5) var<storage, read_write> output_final_candidates: array<FinalCandidate>;
@group(0) @binding(6) var<storage, read_write> output_top_candidates: array<FinalCandidate>;


var<workgroup> topCandidates: array<SortItem, TUNE_MAX_TRIAL_CANDIDATES>;


@compute @workgroup_size(1)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {

    let block_idx = group_id.x;

    //initialize the top candidates array
    for(var i = 0u; i < TUNE_MAX_TRIAL_CANDIDATES; i += 1u) {
        topCandidates[i] = SortItem(ERROR_CALC_DEFAULT, 0u);
	}

    let start_idx = block_idx * uniforms.valid_block_mode_count;
    let trial_count = uniforms.valid_block_mode_count;
    let end_idx = start_idx + trial_count;

    for(var bm_trial_idx = start_idx; bm_trial_idx < end_idx; bm_trial_idx += 1) {
        
        let candidate_error = color_combination_results[bm_trial_idx].total_error;
        
        if (candidate_error < topCandidates[uniforms.tune_candidate_limit - 1u].error) {

            topCandidates[uniforms.tune_candidate_limit - 1u] = SortItem(candidate_error, bm_trial_idx);

            for (var j = uniforms.tune_candidate_limit - 1u; j > 0u; j = j - 1u) {
                if (topCandidates[j].error < topCandidates[j - 1u].error) {
                    let temp = topCandidates[j];
                    topCandidates[j] = topCandidates[j - 1u];
                    topCandidates[j - 1u] = temp;
                }
            }
        }
    }

    //Store the top N candidates
    for(var winner_idx = 0u; winner_idx < uniforms.tune_candidate_limit; winner_idx += 1u) {
        let winner = topCandidates[winner_idx];

        if (winner.error < ERROR_CALC_DEFAULT) {
            let bm_trial_idx = winner.bm_trial_idx;
            let winning_candidate = color_combination_results[bm_trial_idx];

            let bm_lookup_idx = bm_trial_idx % uniforms.valid_block_mode_count;

            let output_idx = block_idx * uniforms.tune_candidate_limit + winner_idx;
            let out_ptr = &output_final_candidates[output_idx];

			(*out_ptr).block_mode_index = valid_block_modes[bm_lookup_idx].block_mode_index;
			(*out_ptr).block_mode_trial_index = bm_trial_idx;
			(*out_ptr).total_error = winning_candidate.total_error;
			(*out_ptr).quant_level = winning_candidate.best_quant_level;
			(*out_ptr).quant_level_mod = winning_candidate.best_quant_level_mod;
			(*out_ptr).formats = winning_candidate.best_ep_formats;

            (*out_ptr).candidate_partitions = ideal_endpoints_and_weights[block_idx].partitions;

            for(var i = 0u; i < BLOCK_MAX_WEIGHTS/4; i += 1u) {
				let unpacked = unpack4xU8(quantization_results[bm_trial_idx].quantized_weights[i]);
                (*out_ptr).quantized_weights[i * 4u + 0u] = unpacked.x;
                (*out_ptr).quantized_weights[i * 4u + 1u] = unpacked.y;
				(*out_ptr).quantized_weights[i * 4u + 2u] = unpacked.z;
				(*out_ptr).quantized_weights[i * 4u + 3u] = unpacked.w;
            }


        }

        //initialize top candidate errors to max error
        let output_idx = block_idx * uniforms.tune_candidate_limit + winner_idx;
        output_top_candidates[output_idx].total_error = ERROR_CALC_DEFAULT;
	}

}const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const BLOCK_MAX_PARTITIONS: u32 = 4u;

const TUNE_MAX_TRIAL_CANDIDATES = 8u;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct DecimationInfo {
    texel_count : u32,
    weight_count : u32,
    weight_x : u32,
    weight_y : u32,

    max_quant_level : u32,
    max_angular_steps : u32,
    max_quant_steps: u32,
    _padding: u32,

    texel_weight_count : array<u32, BLOCK_MAX_TEXELS>,
    texel_weights_offset : array<u32, BLOCK_MAX_TEXELS>,

    weight_texel_count : array<u32, BLOCK_MAX_WEIGHTS>,
    weight_texels_offset : array<u32, BLOCK_MAX_WEIGHTS>,
};

struct TexelToWeightMap {
	weight_index : u32,
	contribution : f32,

    _padding1 : u32,
    _padding2 : u32,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};

struct BlockMode {
	mode_index : u32,
    decimation_mode : u32,
    quant_mode : u32,
    weight_bits : u32,
    is_dual_plane : u32,

    _padding1 : u32,
    _padding2 : u32,
    _padding3 : u32,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct FinalCandidate {
    block_mode_index: u32,
    block_mode_trial_index: u32,
    total_error: f32,
    quant_level: u32, // The original quant level
    quant_level_mod: u32,

    _padding1: u32,

	color_formats_matched: u32,
    final_quant_mode: u32, // The quant mode after checking the mod version

    formats: vec4<u32>,
    quantized_weights: array<u32, BLOCK_MAX_WEIGHTS>,
    candidate_partitions: array<IdealEndpointsAndWeightsPartition, 4>,

	final_formats: vec4<u32>,
	//8 integers per partition
    packed_color_values: array<u32, 32>,
};



@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> decimation_infos: array<DecimationInfo>;
@group(0) @binding(2) var<storage, read> texel_to_weight_map: array<TexelToWeightMap>;
@group(0) @binding(3) var<storage, read> block_modes: array<BlockMode>;
@group(0) @binding(4) var<storage, read> input_blocks: array<InputBlock>;

@group(0) @binding(5) var<storage, read_write> final_candidates: array<FinalCandidate>;
@group(0) @binding(6) var<storage, read_write> candidate_rgbs_vectors: array<vec4<f32>>;



// Undecimated weights of block
var<workgroup> dec_weights: array<f32, BLOCK_MAX_WEIGHTS>;
var<workgroup> undec_weights: array<f32, BLOCK_MAX_TEXELS>;

//precomputed values
var<workgroup> averages: array<vec4<f32>, 4>;
var<workgroup> scale_dirs: array<vec3<f32>, 4>;

// Accumulators for the main reduction, one for each partition
var<workgroup> wmin1: array<atomic<u32>, 4>;
var<workgroup> wmax1: array<atomic<u32>, 4>;
var<workgroup> left_sum_s: array<atomic<u32>, 4>;
var<workgroup> middle_sum_s: array<atomic<u32>, 4>;
var<workgroup> right_sum_s: array<atomic<u32>, 4>;
var<workgroup> scale_min: array<atomic<u32>, 4>;
var<workgroup> scale_max: array<atomic<u32>, 4>;
var<workgroup> color_vec_x: array<atomic<u32>, 16>; // 4 partitions * 4 components
var<workgroup> color_vec_y: array<atomic<u32>, 16>;
var<workgroup> scale_vec: array<atomic<u32>, 8>; // 4 partitions * 2 components


fn atomicMin_f32(atomic_target: ptr<workgroup, atomic<u32>>, value: f32) {
    let val_uint = bitcast<u32>(value);
    var current_min = atomicLoad(atomic_target);
    while (value < bitcast<f32>(current_min)) {
        let result = atomicCompareExchangeWeak(atomic_target, current_min, val_uint);
        if (result.exchanged) {
            break;
        }
        current_min = result.old_value;
    }
}

fn atomicMax_f32(atomic_target: ptr<workgroup, atomic<u32>>, value: f32) {
    let val_uint = bitcast<u32>(value);
    var current_max = atomicLoad(atomic_target);
    while (value > bitcast<f32>(current_max)) {
        let result = atomicCompareExchangeWeak(atomic_target, current_max, val_uint);
        if (result.exchanged) {
            break;
        }
        current_max = result.old_value;
    }
}

fn atomicAdd_f32(atomic_target: ptr<workgroup, atomic<u32>>, value_to_add: f32) {
    loop {
        let original_val_uint = atomicLoad(atomic_target);
        let original_val_float = bitcast<f32>(original_val_uint);
        let new_val_float = original_val_float + value_to_add;
        let new_val_uint = bitcast<u32>(new_val_float);
        let result = atomicCompareExchangeWeak(atomic_target, original_val_uint, new_val_uint);
        if (result.exchanged) {
            break;
        }
    }
}


@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {

    let block_idx = group_id.x;
    let candidate_idx = block_idx * uniforms.tune_candidate_limit + group_id.y;

    let candidate = final_candidates[candidate_idx];
    let bm = block_modes[candidate.block_mode_index];
    let di = decimation_infos[bm.decimation_mode];

    let block_mode_trial_index = candidate.block_mode_trial_index;

    let quantized_weights = candidate.quantized_weights;

    // Unquantize and bilinear infill
    for (var i = local_idx; i < di.weight_count; i += WORKGROUP_SIZE) {
        let weight_int = quantized_weights[i];
        dec_weights[i] = f32(weight_int) / 64.0;
    }
    workgroupBarrier();

    for (var i = local_idx; i < di.texel_count; i += WORKGROUP_SIZE) {
        if (di.texel_count == di.weight_count) {
            // Undecimated Case: Perform a direct copy.
            undec_weights[i] = dec_weights[i];
        } else {
            // Decimated Case: Perform the bilinear infill.
            var infill_val: f32 = 0.0;
            let weight_offset = di.texel_weights_offset[i];
            for (var j = 0u; j < di.texel_weight_count[i]; j = j + 1u) {
                let mapping = texel_to_weight_map[weight_offset + j];
                infill_val += dec_weights[mapping.weight_index] * mapping.contribution;
            }
            undec_weights[i] = infill_val;
        }
    }
    workgroupBarrier();


    let partition_count = uniforms.partition_count;
    let input_block = input_blocks[block_idx];

    // Initialize accumulators
    if(local_idx < partition_count) {
        atomicStore(&wmin1[local_idx], bitcast<u32>(1.0));
        atomicStore(&wmax1[local_idx], bitcast<u32>(0.0));
        atomicStore(&left_sum_s[local_idx], bitcast<u32>(0.0));
        atomicStore(&middle_sum_s[local_idx], bitcast<u32>(0.0));
        atomicStore(&right_sum_s[local_idx], bitcast<u32>(0.0));
        atomicStore(&scale_min[local_idx], bitcast<u32>(1e10));
        atomicStore(&scale_max[local_idx], bitcast<u32>(0.0));
        for (var j = 0u; j < 4u; j = j + 1u) {
			atomicStore(&color_vec_x[local_idx * 4 + j], bitcast<u32>(0.0));
			atomicStore(&color_vec_y[local_idx * 4 + j], bitcast<u32>(0.0));
		}
        for (var j = 0u; j < 2u; j = j + 1u) {
            atomicStore(&scale_vec[local_idx * 2 + j], bitcast<u32>(0.0));
        }

        //precompute averages and scale directions
        averages[local_idx] = candidate.candidate_partitions[local_idx].avg;

        let partition_size = f32(input_block.partition_pixel_counts[local_idx]);
        let rgba_sum = averages[local_idx] * partition_size * uniforms.channel_weights;
        let rgba_weight_sum = max(uniforms.channel_weights * partition_size, vec4<f32>(1e-17));
        scale_dirs[local_idx] = normalize(rgba_sum.xyz / rgba_weight_sum.xyz);
    }

    workgroupBarrier();
    
    
    // Acumulate multiple properties per-partition
    for (var i = local_idx; i < di.texel_count; i += WORKGROUP_SIZE) {

        let p = input_block.texel_partitions[i];
        let rgba = input_block.pixels[i];
        let weight = undec_weights[i];

        atomicMin_f32(&wmin1[p], weight);
        atomicMax_f32(&wmax1[p], weight);

        let scale_dir = scale_dirs[p];

        let scale = dot(rgba.xyz, scale_dir);

        atomicMin_f32(&scale_min[p], scale);
        atomicMax_f32(&scale_max[p], scale);

        let om_weight = 1.0 - weight;

        atomicAdd_f32(&left_sum_s[p], om_weight * om_weight);
        atomicAdd_f32(&middle_sum_s[p], om_weight * weight);
        atomicAdd_f32(&right_sum_s[p], weight * weight);

        let color_y_contrib = rgba * weight;
        atomicAdd_f32(&color_vec_y[p * 4u + 0u], color_y_contrib.r);
        atomicAdd_f32(&color_vec_y[p * 4u + 1u], color_y_contrib.g);
        atomicAdd_f32(&color_vec_y[p * 4u + 2u], color_y_contrib.b);
        atomicAdd_f32(&color_vec_y[p * 4u + 3u], color_y_contrib.a);
        atomicAdd_f32(&color_vec_x[p * 4u + 0u], rgba.r - color_y_contrib.r);
        atomicAdd_f32(&color_vec_x[p * 4u + 1u], rgba.g - color_y_contrib.g);
        atomicAdd_f32(&color_vec_x[p * 4u + 2u], rgba.b - color_y_contrib.b);
        atomicAdd_f32(&color_vec_x[p * 4u + 3u], rgba.a - color_y_contrib.a);

        let ls_weight = uniforms.channel_weights.x + uniforms.channel_weights.y + uniforms.channel_weights.z;

        atomicAdd_f32(&scale_vec[p * 2u + 0u], om_weight * scale * ls_weight);
        atomicAdd_f32(&scale_vec[p * 2u + 1u], weight * scale * ls_weight);
    }

    workgroupBarrier();


    if (local_idx < partition_count) {
        let p = local_idx;
        let color_weight = uniforms.channel_weights;

        // Load all final summed values from shared memory
        let wmin1_val = bitcast<f32>(atomicLoad(&wmin1[p]));
        let wmax1_val = bitcast<f32>(atomicLoad(&wmax1[p]));
        let left_s = bitcast<f32>(atomicLoad(&left_sum_s[p]));
        let middle_s = bitcast<f32>(atomicLoad(&middle_sum_s[p]));
        let right_s = bitcast<f32>(atomicLoad(&right_sum_s[p]));
        let scale_min_val = bitcast<f32>(atomicLoad(&scale_min[p]));
        let scale_max_val = bitcast<f32>(atomicLoad(&scale_max[p]));

        let color_x = vec4<f32>(
			bitcast<f32>(atomicLoad(&color_vec_x[p * 4u + 0u])),
			bitcast<f32>(atomicLoad(&color_vec_x[p * 4u + 1u])),
			bitcast<f32>(atomicLoad(&color_vec_x[p * 4u + 2u])),
			bitcast<f32>(atomicLoad(&color_vec_x[p * 4u + 3u]))
		) * color_weight;

        let color_y = vec4<f32>(
            bitcast<f32>(atomicLoad(&color_vec_y[p * 4u + 0u])),
            bitcast<f32>(atomicLoad(&color_vec_y[p * 4u + 1u])),
            bitcast<f32>(atomicLoad(&color_vec_y[p * 4u + 2u])),
            bitcast<f32>(atomicLoad(&color_vec_y[p * 4u + 3u]))
        ) * color_weight;

        let scale = vec2<f32>(
			bitcast<f32>(atomicLoad(&scale_vec[p * 2u + 0u])),
			bitcast<f32>(atomicLoad(&scale_vec[p * 2u + 1u]))
		);


        let left_sum_v = vec4<f32>(left_s) * color_weight;
        let middle_sum_v = vec4<f32>(middle_s) * color_weight;
        let right_sum_v = vec4<f32>(right_s) * color_weight;

        let ls_weight = uniforms.channel_weights.x + uniforms.channel_weights.y + uniforms.channel_weights.z;
        let lmrs_sum = vec3<f32>(left_s, middle_s, right_s) * ls_weight;
        
        // Initialize the luminance and scale vectors with a reasonable default
        let scalediv = clamp(scale_min_val / max(scale_max_val, 1e-10), 0.0, 1.0);


        let scale_dir = scale_dirs[p];
        let sds = scale_dir * scale_max_val;

        candidate_rgbs_vectors[candidate_idx * BLOCK_MAX_PARTITIONS + p] = vec4<f32>(sds.x, sds.y, sds.z, scalediv);
        let partition_ptr = &final_candidates[candidate_idx].candidate_partitions[p];

        if(wmin1_val >= wmax1_val * 0.999f) {
            // If all weights are equal set endpoints to average

            let partition_size = f32(input_block.partition_pixel_counts[p]);
            let rgba_weight_sum = max(uniforms.channel_weights * partition_size, vec4<f32>(1e-17));
            let avg_color = (color_x + color_y) / rgba_weight_sum;

            //check for NaN
            let notnan_mask = avg_color == avg_color;
            (*partition_ptr).endpoint0 = select(partition_ptr.endpoint0, avg_color, notnan_mask);
			(*partition_ptr).endpoint1 = select(partition_ptr.endpoint1, avg_color, notnan_mask);
            
            candidate_rgbs_vectors[candidate_idx * BLOCK_MAX_PARTITIONS + p] = vec4<f32>(sds.x, sds.y, sds.z, 1.0f);

        }
        else {
            // Complete the analytic calculation of ideal-endpoint-values for the given
			// set of texel weights and pixel colors

            let color_det1 = (left_sum_v * right_sum_v) - (middle_sum_v * middle_sum_v);
            let color_rdet1 = 1.0 / color_det1;

            let ls_det1 = (lmrs_sum.x * lmrs_sum.z) - (lmrs_sum.y * lmrs_sum.y);
            let ls_rdet1 = 1.0 / ls_det1;

            let color_mss1 = (left_sum_v * left_sum_v) + 2 * (middle_sum_v * middle_sum_v) + (right_sum_v * right_sum_v);
            let ls_mss1 = (lmrs_sum.x * lmrs_sum.x) + 2 * (lmrs_sum.y * lmrs_sum.y) + (lmrs_sum.z * lmrs_sum.z);

            let ep0 = (right_sum_v * color_x - middle_sum_v * color_y) * color_rdet1;
            let ep1 = (left_sum_v * color_y - middle_sum_v * color_x) * color_rdet1;

            let det_mask = abs(color_det1) > (color_mss1 * 1e-4);
            let notnan_mask = (ep0 == ep0) & (ep1 == ep1);
            let full_mask = det_mask & notnan_mask;

            (*partition_ptr).endpoint0 = select(partition_ptr.endpoint0, ep0, full_mask);
			(*partition_ptr).endpoint1 = select(partition_ptr.endpoint1, ep1, full_mask);

            let scale_ep0 = (lmrs_sum.z * scale.x - lmrs_sum.y * scale.y) * ls_rdet1;
            let scale_ep1 = (lmrs_sum.x * scale.y - lmrs_sum.y * scale.x) * ls_rdet1;

            if((abs(ls_det1) > (ls_mss1 * 1e-4)) && (scale_ep0 == scale_ep0) && (scale_ep1 == scale_ep1) && (scale_ep0 < scale_ep1)) {
                let scalediv2 = scale_ep0 / scale_ep1;
                let sdsm = scale_dir * scale_ep1;
                candidate_rgbs_vectors[candidate_idx * BLOCK_MAX_PARTITIONS + p] = vec4<f32>(sdsm.x, sdsm.y, sdsm.z, scalediv2);
            }
        }
    }
}const BLOCK_MAX_PARTITIONS: u32 = 4u;
const ERROR_CALC_DEFAULT: f32 = 1e37;
const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;

const TUNE_MAX_TRIAL_CANDIDATES = 8u;

//ASTC endpoint formats
const FMT_LUMINANCE = 0u;
const FMT_LUMINANCE_DELTA = 1u;
const FMT_HDR_LUMINANCE_LARGE_RANGE = 2u;
const FMT_HDR_LUMINANCE_SMALL_RANGE = 3u;
const FMT_LUMINANCE_ALPHA = 4u;
const FMT_LUMINANCE_ALPHA_DELTA = 5u;
const FMT_RGB_SCALE = 6u;
const FMT_HDR_RGB_SCALE = 7u;
const FMT_RGB = 8u;
const FMT_RGB_DELTA = 9u;
const FMT_RGB_SCALE_ALPHA = 10u;
const FMT_HDR_RGB = 11u;
const FMT_RGBA = 12u;
const FMT_RGBA_DELTA = 13u;
const FMT_HDR_RGB_LDR_ALPHA = 14u;
const FMT_HDR_RGBA = 15u;


// Flattened table from the original C++ code
// Size is 17 * 512
const COLOR_UNQUANT_TO_QUANT_TABLE = array<i32, 8704>(
    //QUANT_6
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,
	 51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,
	 51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,
	 51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51, 102, 102, 102, 102, 102, 102,
	102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102,
	102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102,
	102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102,
	153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153,
	153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153,
	153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153,
	153, 153, 153, 153, 153, 153, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204,
	204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204,
	204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204,
	204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    //QUANT_8
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
	  0,   0,   0,   0,   0,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,
	 36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,
	 36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,
	 73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,
	 73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73, 109, 109, 109, 109, 109, 109, 109, 109, 109,
	109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
	109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
	146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146,
	146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146,
	146, 146, 146, 146, 146, 146, 146, 146, 146, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182,
	182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182,
	182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219,
	219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219,
	219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    //QUANT_10
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  28,  28,  28,
	 28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,
	 28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,
	 56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,
	 56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,
	 84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,
	 84,  84,  84,  84,  84,  84, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
	113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
	142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142,
	142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 171, 171, 171, 171, 171, 171,
	171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171,
	171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199,
	199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199,
	199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227,
	227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227,
	227, 227, 227, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    //QUANT_12
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  23,  23,  23,  23,  23,  23,  23,  23,
	 23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,
	 23,  23,  23,  23,  23,  23,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,
	 46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,
	 69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,
	 69,  69,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,
	 92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,
	116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,
	139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139,
	139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,
	163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 186, 186,
	186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186,
	186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209,
	209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 232, 232, 232, 232, 232, 232,
	232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232,
	232, 232, 232, 232, 232, 232, 232, 232, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    //QUANT_16
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,
	 17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,
	 34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,
	 51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  68,  68,  68,  68,  68,  68,  68,  68,
	 68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  85,  85,  85,  85,  85,  85,
	 85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85,  85, 102, 102, 102, 102,
	102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 119, 119,
	119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
	136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
	136, 136, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153,
	153, 153, 153, 153, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
	170, 170, 170, 170, 170, 170, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187,
	187, 187, 187, 187, 187, 187, 187, 187, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204,
	204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221,
	221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238,
	238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    //QUANT_20
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,
	 13,  13,  13,  13,  13,  13,  13,  13,  13,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,
	 27,  27,  27,  27,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  54,
	 54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  67,  67,  67,  67,  67,  67,
	 67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,
	 80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  94,  94,  94,  94,  94,  94,  94,  94,  94,  94,  94,  94,  94,  94,  94,  94,  94,
	 94,  94,  94,  94,  94,  94,  94,  94,  94,  94, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,
	107, 107, 107, 107, 107, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,
	134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 148, 148, 148, 148, 148,
	148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161,
	161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175,
	175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188, 188,
	188, 188, 188, 188, 188, 188, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201,
	201, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 228, 228, 228, 228,
	228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 242, 242, 242, 242, 242, 242, 242, 242, 242,
	242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    //QUANT_24
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
	 11,  11,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  33,  33,  33,  33,  33,  33,  33,  33,
	 33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,
	 44,  44,  44,  44,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  66,  66,  66,  66,  66,  66,
	 66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  77,  77,  77,  77,  77,  77,  77,  77,  77,  77,  77,  77,  77,  77,  77,  77,
	 77,  77,  77,  77,  77,  77,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  88,  99,  99,  99,  99,
	 99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
	110, 110, 110, 110, 110, 110, 110, 110, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121,
	134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 145, 145, 145, 145, 145, 145, 145, 145,
	145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156,
	156, 156, 156, 156, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 178, 178, 178, 178, 178, 178,
	178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189,
	189, 189, 189, 189, 189, 189, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 211, 211, 211, 211,
	211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222,
	222, 222, 222, 222, 222, 222, 222, 222, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 244, 244,
	244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    //QUANT_32
      0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,  16,  16,  16,  16,  16,  16,  16,
	 16,  16,  16,  16,  16,  16,  16,  16,  16,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  33,  33,  33,  33,  33,  33,
	 33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  49,  49,  49,  49,  49,
	 49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  66,  66,  66,  66,
	 66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  82,  82,  82,
	 82,  82,  82,  82,  82,  82,  82,  82,  82,  82,  82,  82,  82,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  99,  99,
	 99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,  99, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 115,
	115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
	132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,
	140, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156,
	156, 156, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173,
	173, 173, 173, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189,
	189, 189, 189, 189, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206,
	206, 206, 206, 206, 206, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222,
	222, 222, 222, 222, 222, 222, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 239, 239, 239, 239, 239, 239, 239, 239, 239,
	239, 239, 239, 239, 239, 239, 239, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    //QUANT_40
      0,   0,   0,   0,   0,   0,   0,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,
	 13,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  32,  32,  32,  32,  32,
	 32,  32,  32,  32,  32,  32,  32,  32,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,
	 45,  45,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  65,  65,  65,  65,
	 65,  65,  65,  65,  65,  65,  65,  65,  65,  71,  71,  71,  71,  71,  71,  71,  71,  71,  71,  71,  71,  71,  78,  78,  78,  78,  78,  78,  78,  78,  78,  78,
	 78,  78,  78,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  97,  97,  97,
	 97,  97,  97,  97,  97,  97,  97,  97,  97,  97, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 110, 110, 110, 110, 110, 110, 110, 110, 110,
	110, 110, 110, 110, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
	132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 138, 138, 138, 138, 138, 138, 138, 138, 138, 138, 138, 138, 138, 145, 145, 145, 145,
	145, 145, 145, 145, 145, 145, 145, 145, 145, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 151, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158,
	158, 158, 158, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 177, 177, 177,
	177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 184, 184, 184, 184, 184, 184, 184, 184, 184, 184, 184, 184, 184, 190, 190, 190, 190, 190, 190, 190, 190, 190,
	190, 190, 190, 190, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 210, 210,
	210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 223, 223, 223, 223, 223, 223, 223, 223,
	223, 223, 223, 223, 223, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 242,
	242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 255, 255, 255, 255, 255, 255, 255,
    //QUANT_48
      0,   0,   0,   0,   0,   0,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  16,  16,  16,  16,
	 16,  16,  16,  16,  16,  16,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  32,  32,  32,  32,
	 32,  32,  32,  32,  32,  32,  32,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  48,  48,  48,  48,
	 48,  48,  48,  48,  48,  48,  48,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  65,  65,  65,
	 65,  65,  65,  65,  65,  65,  65,  65,  70,  70,  70,  70,  70,  70,  70,  70,  70,  70,  70,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  81,  81,
	 81,  81,  81,  81,  81,  81,  81,  81,  86,  86,  86,  86,  86,  86,  86,  86,  86,  86,  86,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  97,  97,
	 97,  97,  97,  97,  97,  97,  97,  97,  97, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 113, 113,
	113, 113, 113, 113, 113, 113, 113, 113, 113, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124,
	131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 142, 142, 142, 142, 142, 142, 142, 142, 142,
	142, 142, 147, 147, 147, 147, 147, 147, 147, 147, 147, 147, 152, 152, 152, 152, 152, 152, 152, 152, 152, 152, 152, 158, 158, 158, 158, 158, 158, 158, 158, 158,
	158, 158, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 169, 169, 169, 169, 169, 169, 169, 169, 169, 169, 169, 174, 174, 174, 174, 174, 174, 174, 174,
	174, 174, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 190, 190, 190, 190, 190, 190, 190, 190,
	190, 190, 190, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 196, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 207, 207, 207, 207, 207, 207, 207,
	207, 207, 207, 207, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 223, 223, 223, 223, 223, 223, 223,
	223, 223, 223, 223, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 228, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 239, 239, 239, 239, 239, 239,
	239, 239, 239, 239, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 255, 255, 255, 255, 255, 255,
    //QUANT_64
      0,   0,   0,   0,   0,   4,   4,   4,   4,   4,   4,   4,   4,   8,   8,   8,   8,   8,   8,   8,   8,  12,  12,  12,  12,  12,  12,  12,  12,  16,  16,  16,
	 16,  16,  16,  16,  16,  20,  20,  20,  20,  20,  20,  20,  20,  24,  24,  24,  24,  24,  24,  24,  24,  28,  28,  28,  28,  28,  28,  28,  28,  32,  32,  32,
	 32,  32,  32,  32,  32,  36,  36,  36,  36,  36,  36,  36,  36,  40,  40,  40,  40,  40,  40,  40,  40,  44,  44,  44,  44,  44,  44,  44,  44,  48,  48,  48,
	 48,  48,  48,  48,  48,  52,  52,  52,  52,  52,  52,  52,  52,  56,  56,  56,  56,  56,  56,  56,  56,  60,  60,  60,  60,  60,  60,  60,  60,  60,  65,  65,
	 65,  65,  65,  65,  65,  65,  65,  69,  69,  69,  69,  69,  69,  69,  69,  73,  73,  73,  73,  73,  73,  73,  73,  77,  77,  77,  77,  77,  77,  77,  77,  81,
	 81,  81,  81,  81,  81,  81,  81,  85,  85,  85,  85,  85,  85,  85,  85,  89,  89,  89,  89,  89,  89,  89,  89,  93,  93,  93,  93,  93,  93,  93,  93,  97,
	 97,  97,  97,  97,  97,  97,  97, 101, 101, 101, 101, 101, 101, 101, 101, 105, 105, 105, 105, 105, 105, 105, 105, 109, 109, 109, 109, 109, 109, 109, 109, 113,
	113, 113, 113, 113, 113, 113, 113, 117, 117, 117, 117, 117, 117, 117, 117, 121, 121, 121, 121, 121, 121, 121, 121, 125, 125, 125, 125, 125, 125, 125, 125, 125,
	130, 130, 130, 130, 130, 130, 130, 130, 130, 134, 134, 134, 134, 134, 134, 134, 134, 138, 138, 138, 138, 138, 138, 138, 138, 142, 142, 142, 142, 142, 142, 142,
	142, 146, 146, 146, 146, 146, 146, 146, 146, 150, 150, 150, 150, 150, 150, 150, 150, 154, 154, 154, 154, 154, 154, 154, 154, 158, 158, 158, 158, 158, 158, 158,
	158, 162, 162, 162, 162, 162, 162, 162, 162, 166, 166, 166, 166, 166, 166, 166, 166, 170, 170, 170, 170, 170, 170, 170, 170, 174, 174, 174, 174, 174, 174, 174,
	174, 178, 178, 178, 178, 178, 178, 178, 178, 182, 182, 182, 182, 182, 182, 182, 182, 186, 186, 186, 186, 186, 186, 186, 186, 190, 190, 190, 190, 190, 190, 190,
	190, 190, 195, 195, 195, 195, 195, 195, 195, 195, 195, 199, 199, 199, 199, 199, 199, 199, 199, 203, 203, 203, 203, 203, 203, 203, 203, 207, 207, 207, 207, 207,
	207, 207, 207, 211, 211, 211, 211, 211, 211, 211, 211, 215, 215, 215, 215, 215, 215, 215, 215, 219, 219, 219, 219, 219, 219, 219, 219, 223, 223, 223, 223, 223,
	223, 223, 223, 227, 227, 227, 227, 227, 227, 227, 227, 231, 231, 231, 231, 231, 231, 231, 231, 235, 235, 235, 235, 235, 235, 235, 235, 239, 239, 239, 239, 239,
	239, 239, 239, 243, 243, 243, 243, 243, 243, 243, 243, 247, 247, 247, 247, 247, 247, 247, 247, 251, 251, 251, 251, 251, 251, 251, 251, 255, 255, 255, 255, 255,
    //QUANT_80
      0,   0,   0,   0,   3,   3,   3,   3,   3,   3,   6,   6,   6,   6,   6,   6,   9,   9,   9,   9,   9,   9,   9,  13,  13,  13,  13,  13,  13,  13,  16,  16,
	 16,  16,  16,  16,  19,  19,  19,  19,  19,  19,  22,  22,  22,  22,  22,  22,  25,  25,  25,  25,  25,  25,  25,  29,  29,  29,  29,  29,  29,  29,  32,  32,
	 32,  32,  32,  32,  35,  35,  35,  35,  35,  35,  38,  38,  38,  38,  38,  38,  38,  42,  42,  42,  42,  42,  42,  42,  45,  45,  45,  45,  45,  45,  48,  48,
	 48,  48,  48,  48,  51,  51,  51,  51,  51,  51,  54,  54,  54,  54,  54,  54,  54,  58,  58,  58,  58,  58,  58,  58,  61,  61,  61,  61,  61,  61,  64,  64,
	 64,  64,  64,  64,  67,  67,  67,  67,  67,  67,  67,  71,  71,  71,  71,  71,  71,  71,  74,  74,  74,  74,  74,  74,  77,  77,  77,  77,  77,  77,  80,  80,
	 80,  80,  80,  80,  83,  83,  83,  83,  83,  83,  83,  87,  87,  87,  87,  87,  87,  87,  90,  90,  90,  90,  90,  90,  93,  93,  93,  93,  93,  93,  96,  96,
	 96,  96,  96,  96,  96, 100, 100, 100, 100, 100, 100, 100, 103, 103, 103, 103, 103, 103, 106, 106, 106, 106, 106, 106, 109, 109, 109, 109, 109, 109, 112, 112,
	112, 112, 112, 112, 112, 116, 116, 116, 116, 116, 116, 116, 119, 119, 119, 119, 119, 119, 122, 122, 122, 122, 122, 122, 125, 125, 125, 125, 125, 125, 125, 125,
	130, 130, 130, 130, 130, 130, 130, 130, 133, 133, 133, 133, 133, 133, 136, 136, 136, 136, 136, 136, 139, 139, 139, 139, 139, 139, 139, 143, 143, 143, 143, 143,
	143, 143, 146, 146, 146, 146, 146, 146, 149, 149, 149, 149, 149, 149, 152, 152, 152, 152, 152, 152, 155, 155, 155, 155, 155, 155, 155, 159, 159, 159, 159, 159,
	159, 159, 162, 162, 162, 162, 162, 162, 165, 165, 165, 165, 165, 165, 168, 168, 168, 168, 168, 168, 168, 172, 172, 172, 172, 172, 172, 172, 175, 175, 175, 175,
	175, 175, 178, 178, 178, 178, 178, 178, 181, 181, 181, 181, 181, 181, 184, 184, 184, 184, 184, 184, 184, 188, 188, 188, 188, 188, 188, 188, 191, 191, 191, 191,
	191, 191, 194, 194, 194, 194, 194, 194, 197, 197, 197, 197, 197, 197, 197, 201, 201, 201, 201, 201, 201, 201, 204, 204, 204, 204, 204, 204, 207, 207, 207, 207,
	207, 207, 210, 210, 210, 210, 210, 210, 213, 213, 213, 213, 213, 213, 213, 217, 217, 217, 217, 217, 217, 217, 220, 220, 220, 220, 220, 220, 223, 223, 223, 223,
	223, 223, 226, 226, 226, 226, 226, 226, 226, 230, 230, 230, 230, 230, 230, 230, 233, 233, 233, 233, 233, 233, 236, 236, 236, 236, 236, 236, 239, 239, 239, 239,
	239, 239, 242, 242, 242, 242, 242, 242, 242, 246, 246, 246, 246, 246, 246, 246, 249, 249, 249, 249, 249, 249, 252, 252, 252, 252, 252, 252, 255, 255, 255, 255,
    //QUANT_96
      0,   0,   0,   2,   2,   2,   2,   2,   5,   5,   5,   5,   5,   5,   8,   8,   8,   8,   8,  10,  10,  10,  10,  10,  13,  13,  13,  13,  13,  13,  16,  16,
	 16,  16,  16,  18,  18,  18,  18,  18,  21,  21,  21,  21,  21,  21,  24,  24,  24,  24,  24,  26,  26,  26,  26,  26,  29,  29,  29,  29,  29,  29,  32,  32,
	 32,  32,  32,  32,  35,  35,  35,  35,  35,  37,  37,  37,  37,  37,  40,  40,  40,  40,  40,  40,  43,  43,  43,  43,  43,  45,  45,  45,  45,  45,  48,  48,
	 48,  48,  48,  48,  51,  51,  51,  51,  51,  53,  53,  53,  53,  53,  56,  56,  56,  56,  56,  56,  59,  59,  59,  59,  59,  61,  61,  61,  61,  61,  64,  64,
	 64,  64,  64,  64,  67,  67,  67,  67,  67,  67,  70,  70,  70,  70,  70,  72,  72,  72,  72,  72,  75,  75,  75,  75,  75,  75,  78,  78,  78,  78,  78,  80,
	 80,  80,  80,  80,  83,  83,  83,  83,  83,  83,  86,  86,  86,  86,  86,  88,  88,  88,  88,  88,  91,  91,  91,  91,  91,  91,  94,  94,  94,  94,  94,  96,
	 96,  96,  96,  96,  99,  99,  99,  99,  99,  99, 102, 102, 102, 102, 102, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 107, 110, 110, 110, 110, 110, 112,
	112, 112, 112, 112, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 120, 120, 120, 120, 120, 123, 123, 123, 123, 123, 123, 126, 126, 126, 126, 126, 126,
	129, 129, 129, 129, 129, 129, 132, 132, 132, 132, 132, 132, 135, 135, 135, 135, 135, 137, 137, 137, 137, 137, 140, 140, 140, 140, 140, 140, 143, 143, 143, 143,
	143, 145, 145, 145, 145, 145, 148, 148, 148, 148, 148, 148, 151, 151, 151, 151, 151, 153, 153, 153, 153, 153, 156, 156, 156, 156, 156, 156, 159, 159, 159, 159,
	159, 161, 161, 161, 161, 161, 164, 164, 164, 164, 164, 164, 167, 167, 167, 167, 167, 169, 169, 169, 169, 169, 172, 172, 172, 172, 172, 172, 175, 175, 175, 175,
	175, 177, 177, 177, 177, 177, 180, 180, 180, 180, 180, 180, 183, 183, 183, 183, 183, 185, 185, 185, 185, 185, 188, 188, 188, 188, 188, 188, 191, 191, 191, 191,
	191, 191, 194, 194, 194, 194, 194, 196, 196, 196, 196, 196, 199, 199, 199, 199, 199, 199, 202, 202, 202, 202, 202, 204, 204, 204, 204, 204, 207, 207, 207, 207,
	207, 207, 210, 210, 210, 210, 210, 212, 212, 212, 212, 212, 215, 215, 215, 215, 215, 215, 218, 218, 218, 218, 218, 220, 220, 220, 220, 220, 223, 223, 223, 223,
	223, 223, 226, 226, 226, 226, 226, 226, 229, 229, 229, 229, 229, 231, 231, 231, 231, 231, 234, 234, 234, 234, 234, 234, 237, 237, 237, 237, 237, 239, 239, 239,
	239, 239, 242, 242, 242, 242, 242, 242, 245, 245, 245, 245, 245, 247, 247, 247, 247, 247, 250, 250, 250, 250, 250, 250, 253, 253, 253, 253, 253, 255, 255, 255,
    //QUANT_128
      0,   0,   0,   2,   2,   2,   2,   4,   4,   4,   4,   6,   6,   6,   6,   8,   8,   8,   8,  10,  10,  10,  10,  12,  12,  12,  12,  14,  14,  14,  14,  16,
	 16,  16,  16,  18,  18,  18,  18,  20,  20,  20,  20,  22,  22,  22,  22,  24,  24,  24,  24,  26,  26,  26,  26,  28,  28,  28,  28,  30,  30,  30,  30,  32,
	 32,  32,  32,  34,  34,  34,  34,  36,  36,  36,  36,  38,  38,  38,  38,  40,  40,  40,  40,  42,  42,  42,  42,  44,  44,  44,  44,  46,  46,  46,  46,  48,
	 48,  48,  48,  50,  50,  50,  50,  52,  52,  52,  52,  54,  54,  54,  54,  56,  56,  56,  56,  58,  58,  58,  58,  60,  60,  60,  60,  62,  62,  62,  62,  64,
	 64,  64,  64,  66,  66,  66,  66,  68,  68,  68,  68,  70,  70,  70,  70,  72,  72,  72,  72,  74,  74,  74,  74,  76,  76,  76,  76,  78,  78,  78,  78,  80,
	 80,  80,  80,  82,  82,  82,  82,  84,  84,  84,  84,  86,  86,  86,  86,  88,  88,  88,  88,  90,  90,  90,  90,  92,  92,  92,  92,  94,  94,  94,  94,  96,
	 96,  96,  96,  98,  98,  98,  98, 100, 100, 100, 100, 102, 102, 102, 102, 104, 104, 104, 104, 106, 106, 106, 106, 108, 108, 108, 108, 110, 110, 110, 110, 112,
	112, 112, 112, 114, 114, 114, 114, 116, 116, 116, 116, 118, 118, 118, 118, 120, 120, 120, 120, 122, 122, 122, 122, 124, 124, 124, 124, 126, 126, 126, 126, 126,
	129, 129, 129, 129, 129, 131, 131, 131, 131, 133, 133, 133, 133, 135, 135, 135, 135, 137, 137, 137, 137, 139, 139, 139, 139, 141, 141, 141, 141, 143, 143, 143,
	143, 145, 145, 145, 145, 147, 147, 147, 147, 149, 149, 149, 149, 151, 151, 151, 151, 153, 153, 153, 153, 155, 155, 155, 155, 157, 157, 157, 157, 159, 159, 159,
	159, 161, 161, 161, 161, 163, 163, 163, 163, 165, 165, 165, 165, 167, 167, 167, 167, 169, 169, 169, 169, 171, 171, 171, 171, 173, 173, 173, 173, 175, 175, 175,
	175, 177, 177, 177, 177, 179, 179, 179, 179, 181, 181, 181, 181, 183, 183, 183, 183, 185, 185, 185, 185, 187, 187, 187, 187, 189, 189, 189, 189, 191, 191, 191,
	191, 193, 193, 193, 193, 195, 195, 195, 195, 197, 197, 197, 197, 199, 199, 199, 199, 201, 201, 201, 201, 203, 203, 203, 203, 205, 205, 205, 205, 207, 207, 207,
	207, 209, 209, 209, 209, 211, 211, 211, 211, 213, 213, 213, 213, 215, 215, 215, 215, 217, 217, 217, 217, 219, 219, 219, 219, 221, 221, 221, 221, 223, 223, 223,
	223, 225, 225, 225, 225, 227, 227, 227, 227, 229, 229, 229, 229, 231, 231, 231, 231, 233, 233, 233, 233, 235, 235, 235, 235, 237, 237, 237, 237, 239, 239, 239,
	239, 241, 241, 241, 241, 243, 243, 243, 243, 245, 245, 245, 245, 247, 247, 247, 247, 249, 249, 249, 249, 251, 251, 251, 251, 253, 253, 253, 253, 255, 255, 255,
    //QUANT_160
      0,   0,   1,   1,   1,   3,   3,   3,   4,   4,   4,   6,   6,   6,   6,   8,   8,   8,   9,   9,   9,  11,  11,  11,  12,  12,  12,  14,  14,  14,  14,  16,
	 16,  16,  17,  17,  17,  19,  19,  19,  20,  20,  20,  22,  22,  22,  22,  24,  24,  24,  25,  25,  25,  27,  27,  27,  28,  28,  28,  30,  30,  30,  30,  32,
	 32,  32,  33,  33,  33,  35,  35,  35,  36,  36,  36,  38,  38,  38,  38,  40,  40,  40,  41,  41,  41,  43,  43,  43,  44,  44,  44,  46,  46,  46,  46,  48,
	 48,  48,  49,  49,  49,  51,  51,  51,  52,  52,  52,  54,  54,  54,  54,  56,  56,  56,  57,  57,  57,  59,  59,  59,  60,  60,  60,  62,  62,  62,  62,  64,
	 64,  64,  65,  65,  65,  67,  67,  67,  68,  68,  68,  70,  70,  70,  70,  72,  72,  72,  73,  73,  73,  75,  75,  75,  76,  76,  76,  78,  78,  78,  78,  80,
	 80,  80,  81,  81,  81,  83,  83,  83,  84,  84,  84,  86,  86,  86,  86,  88,  88,  88,  89,  89,  89,  91,  91,  91,  92,  92,  92,  94,  94,  94,  94,  96,
	 96,  96,  97,  97,  97,  99,  99,  99, 100, 100, 100, 102, 102, 102, 102, 104, 104, 104, 105, 105, 105, 107, 107, 107, 108, 108, 108, 110, 110, 110, 110, 112,
	112, 112, 113, 113, 113, 115, 115, 115, 116, 116, 116, 118, 118, 118, 118, 120, 120, 120, 121, 121, 121, 123, 123, 123, 124, 124, 124, 126, 126, 126, 126, 126,
	129, 129, 129, 129, 129, 131, 131, 131, 132, 132, 132, 134, 134, 134, 135, 135, 135, 137, 137, 137, 137, 139, 139, 139, 140, 140, 140, 142, 142, 142, 143, 143,
	143, 145, 145, 145, 145, 147, 147, 147, 148, 148, 148, 150, 150, 150, 151, 151, 151, 153, 153, 153, 153, 155, 155, 155, 156, 156, 156, 158, 158, 158, 159, 159,
	159, 161, 161, 161, 161, 163, 163, 163, 164, 164, 164, 166, 166, 166, 167, 167, 167, 169, 169, 169, 169, 171, 171, 171, 172, 172, 172, 174, 174, 174, 175, 175,
	175, 177, 177, 177, 177, 179, 179, 179, 180, 180, 180, 182, 182, 182, 183, 183, 183, 185, 185, 185, 185, 187, 187, 187, 188, 188, 188, 190, 190, 190, 191, 191,
	191, 193, 193, 193, 193, 195, 195, 195, 196, 196, 196, 198, 198, 198, 199, 199, 199, 201, 201, 201, 201, 203, 203, 203, 204, 204, 204, 206, 206, 206, 207, 207,
	207, 209, 209, 209, 209, 211, 211, 211, 212, 212, 212, 214, 214, 214, 215, 215, 215, 217, 217, 217, 217, 219, 219, 219, 220, 220, 220, 222, 222, 222, 223, 223,
	223, 225, 225, 225, 225, 227, 227, 227, 228, 228, 228, 230, 230, 230, 231, 231, 231, 233, 233, 233, 233, 235, 235, 235, 236, 236, 236, 238, 238, 238, 239, 239,
	239, 241, 241, 241, 241, 243, 243, 243, 244, 244, 244, 246, 246, 246, 247, 247, 247, 249, 249, 249, 249, 251, 251, 251, 252, 252, 252, 254, 254, 254, 255, 255,
    //QUANT_192
      0,   0,   1,   1,   2,   2,   2,   4,   4,   4,   5,   5,   6,   6,   6,   8,   8,   8,   9,   9,  10,  10,  10,  12,  12,  12,  13,  13,  14,  14,  14,  16,
	 16,  16,  17,  17,  18,  18,  18,  20,  20,  20,  21,  21,  22,  22,  22,  24,  24,  24,  25,  25,  26,  26,  26,  28,  28,  28,  29,  29,  30,  30,  30,  32,
	 32,  32,  33,  33,  34,  34,  34,  36,  36,  36,  37,  37,  38,  38,  38,  40,  40,  40,  41,  41,  42,  42,  42,  44,  44,  44,  45,  45,  46,  46,  46,  48,
	 48,  48,  49,  49,  50,  50,  50,  52,  52,  52,  53,  53,  54,  54,  54,  56,  56,  56,  57,  57,  58,  58,  58,  60,  60,  60,  61,  61,  62,  62,  62,  64,
	 64,  64,  65,  65,  66,  66,  66,  68,  68,  68,  69,  69,  70,  70,  70,  72,  72,  72,  73,  73,  74,  74,  74,  76,  76,  76,  77,  77,  78,  78,  78,  80,
	 80,  80,  81,  81,  82,  82,  82,  84,  84,  84,  85,  85,  86,  86,  86,  88,  88,  88,  89,  89,  90,  90,  90,  92,  92,  92,  93,  93,  94,  94,  94,  96,
	 96,  96,  97,  97,  98,  98,  98, 100, 100, 100, 101, 101, 102, 102, 102, 104, 104, 104, 105, 105, 106, 106, 106, 108, 108, 108, 109, 109, 110, 110, 110, 112,
	112, 112, 113, 113, 114, 114, 114, 116, 116, 116, 117, 117, 118, 118, 118, 120, 120, 120, 121, 121, 122, 122, 122, 124, 124, 124, 125, 125, 126, 126, 126, 126,
	129, 129, 129, 129, 130, 130, 131, 131, 131, 133, 133, 133, 134, 134, 135, 135, 135, 137, 137, 137, 138, 138, 139, 139, 139, 141, 141, 141, 142, 142, 143, 143,
	143, 145, 145, 145, 146, 146, 147, 147, 147, 149, 149, 149, 150, 150, 151, 151, 151, 153, 153, 153, 154, 154, 155, 155, 155, 157, 157, 157, 158, 158, 159, 159,
	159, 161, 161, 161, 162, 162, 163, 163, 163, 165, 165, 165, 166, 166, 167, 167, 167, 169, 169, 169, 170, 170, 171, 171, 171, 173, 173, 173, 174, 174, 175, 175,
	175, 177, 177, 177, 178, 178, 179, 179, 179, 181, 181, 181, 182, 182, 183, 183, 183, 185, 185, 185, 186, 186, 187, 187, 187, 189, 189, 189, 190, 190, 191, 191,
	191, 193, 193, 193, 194, 194, 195, 195, 195, 197, 197, 197, 198, 198, 199, 199, 199, 201, 201, 201, 202, 202, 203, 203, 203, 205, 205, 205, 206, 206, 207, 207,
	207, 209, 209, 209, 210, 210, 211, 211, 211, 213, 213, 213, 214, 214, 215, 215, 215, 217, 217, 217, 218, 218, 219, 219, 219, 221, 221, 221, 222, 222, 223, 223,
	223, 225, 225, 225, 226, 226, 227, 227, 227, 229, 229, 229, 230, 230, 231, 231, 231, 233, 233, 233, 234, 234, 235, 235, 235, 237, 237, 237, 238, 238, 239, 239,
	239, 241, 241, 241, 242, 242, 243, 243, 243, 245, 245, 245, 246, 246, 247, 247, 247, 249, 249, 249, 250, 250, 251, 251, 251, 253, 253, 253, 254, 254, 255, 255,
	//QUANT_256
	  0,   0,   1,   1,   2,   2,   3,   3,   4,   4,   5,   5,   6,   6,   7,   7,   8,   8,   9,   9,  10,  10,  11,  11,  12,  12,  13,  13,  14,  14,  15,  15,
	 16,  16,  17,  17,  18,  18,  19,  19,  20,  20,  21,  21,  22,  22,  23,  23,  24,  24,  25,  25,  26,  26,  27,  27,  28,  28,  29,  29,  30,  30,  31,  31,
	 32,  32,  33,  33,  34,  34,  35,  35,  36,  36,  37,  37,  38,  38,  39,  39,  40,  40,  41,  41,  42,  42,  43,  43,  44,  44,  45,  45,  46,  46,  47,  47,
	 48,  48,  49,  49,  50,  50,  51,  51,  52,  52,  53,  53,  54,  54,  55,  55,  56,  56,  57,  57,  58,  58,  59,  59,  60,  60,  61,  61,  62,  62,  63,  63,
	 64,  64,  65,  65,  66,  66,  67,  67,  68,  68,  69,  69,  70,  70,  71,  71,  72,  72,  73,  73,  74,  74,  75,  75,  76,  76,  77,  77,  78,  78,  79,  79,
	 80,  80,  81,  81,  82,  82,  83,  83,  84,  84,  85,  85,  86,  86,  87,  87,  88,  88,  89,  89,  90,  90,  91,  91,  92,  92,  93,  93,  94,  94,  95,  95,
	 96,  96,  97,  97,  98,  98,  99,  99, 100, 100, 101, 101, 102, 102, 103, 103, 104, 104, 105, 105, 106, 106, 107, 107, 108, 108, 109, 109, 110, 110, 111, 111,
	112, 112, 113, 113, 114, 114, 115, 115, 116, 116, 117, 117, 118, 118, 119, 119, 120, 120, 121, 121, 122, 122, 123, 123, 124, 124, 125, 125, 126, 126, 127, 127,
	128, 128, 129, 129, 130, 130, 131, 131, 132, 132, 133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138, 139, 139, 140, 140, 141, 141, 142, 142, 143, 143,
	144, 144, 145, 145, 146, 146, 147, 147, 148, 148, 149, 149, 150, 150, 151, 151, 152, 152, 153, 153, 154, 154, 155, 155, 156, 156, 157, 157, 158, 158, 159, 159,
	160, 160, 161, 161, 162, 162, 163, 163, 164, 164, 165, 165, 166, 166, 167, 167, 168, 168, 169, 169, 170, 170, 171, 171, 172, 172, 173, 173, 174, 174, 175, 175,
	176, 176, 177, 177, 178, 178, 179, 179, 180, 180, 181, 181, 182, 182, 183, 183, 184, 184, 185, 185, 186, 186, 187, 187, 188, 188, 189, 189, 190, 190, 191, 191,
	192, 192, 193, 193, 194, 194, 195, 195, 196, 196, 197, 197, 198, 198, 199, 199, 200, 200, 201, 201, 202, 202, 203, 203, 204, 204, 205, 205, 206, 206, 207, 207,
	208, 208, 209, 209, 210, 210, 211, 211, 212, 212, 213, 213, 214, 214, 215, 215, 216, 216, 217, 217, 218, 218, 219, 219, 220, 220, 221, 221, 222, 222, 223, 223,
	224, 224, 225, 225, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 233, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239, 239,
	240, 240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 246, 246, 247, 247, 248, 248, 249, 249, 250, 250, 251, 251, 252, 252, 253, 253, 254, 254, 255, 255
);


//------------------------------------------------------------------------------------------------

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};


struct FinalCandidate {
    block_mode_index: u32,
    block_mode_trial_index: u32,
    total_error: f32,
    quant_level: u32, // The original quant level
    quant_level_mod: u32,

    _padding1: u32,

	color_formats_matched: u32,
    final_quant_mode: u32, // The quant mode after checking the mod version

    formats: vec4<u32>,
    quantized_weights: array<u32, BLOCK_MAX_WEIGHTS>,
    candidate_partitions: array<IdealEndpointsAndWeightsPartition, 4>,

	final_formats: vec4<u32>, //Formats can change after quantization
    packed_color_values: array<u32, 32>, //8 integers per partition
};

struct PackedPartitionResult {
    values: array<u32, 8>,
	format: u32,
};

//------------------------------------------------------------------------------------------------

@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> candidate_rgbs_vectors: array<vec4<f32>>;

@group(0) @binding(2) var<storage, read_write> final_candidates: array<FinalCandidate>;

//------------------------------------------------------------------------------------------------

fn get_rgba_encoding_error(
	uquant0: vec4<f32>,
	uquant1: vec4<f32>,
	quant0: vec4<i32>,
	quant1: vec4<i32>
) -> f32 {
	let error0 = uquant0 - vec4<f32>(quant0);
	let error1 = uquant1 - vec4<f32>(quant1);
	let error = error0 * error0 + error1 * error1;
	return error.r + error.g + error.b + error.a;
}

fn quant_color3_int(quant_level: u32, value: vec4<i32>) -> vec4<i32> {
	let index = value * 2 + 1;
	let quant_index = i32(quant_level - 4); //QUANT_6 = 4
	return vec4<i32>(
		COLOR_UNQUANT_TO_QUANT_TABLE[quant_index * 512 + index.r],
		COLOR_UNQUANT_TO_QUANT_TABLE[quant_index * 512 + index.g],
		COLOR_UNQUANT_TO_QUANT_TABLE[quant_index * 512 + index.b],
		0 // Alpha channel is not used in this context
	);
}

fn quant_color3_flt(quant_level: u32, value: vec4<i32>, valuef: vec4<f32>) -> vec4<i32> {
	var index = value * 2;

	//Compute the residual to determine if we should round down or up tiles
	let residual = valuef - vec4<f32>(value);
	let mask = residual >= vec4<f32>(-0.1f);
	index = select(index, index + 1, mask);

	let quant_index = i32(quant_level - 4); //QUANT_6 = 4
	return vec4<i32>(
		COLOR_UNQUANT_TO_QUANT_TABLE[quant_index * 512 + index.r],
		COLOR_UNQUANT_TO_QUANT_TABLE[quant_index * 512 + index.g],
		COLOR_UNQUANT_TO_QUANT_TABLE[quant_index * 512 + index.b],
		0 // Alpha channel is not used in this context
	);
}

fn quant_color_int(quant_level: u32, value: i32) -> u32 {
	let index = value * 2 + 1;
	let quant_index = i32(quant_level - 4); //QUANT_6 = 4
	return u32(COLOR_UNQUANT_TO_QUANT_TABLE[quant_index * 512 + index]);
}

fn quant_color_flt(quant_level: u32, value: i32, valuef: f32) -> u32 {
	var index = value * 2;

	// Compute the residual to determine if we should round down or up ties.
	let residual = valuef - f32(value);
	if(residual >= -0.1f) {
		index += 1;
	}

	let quant_index = i32(quant_level - 4); //QUANT_6 = 4
	return u32(COLOR_UNQUANT_TO_QUANT_TABLE[quant_index * 512 + index]);
}

fn bit_transfer_signed(input0: ptr<function, vec4<i32>>, input1: ptr<function, vec4<i32>>) {
    var input0_val = *input0;
    var input1_val = *input1;

    //preform shifts on unsigned interegers to guarantee logical shifts
    let input0_val_u = bitcast<vec4<u32>>(input0_val);
    let input1_val_u = bitcast<vec4<u32>>(input1_val);

    input1_val =  bitcast<vec4<i32>>((input1_val_u >> vec4<u32>(1)) | (input0_val_u & vec4<u32>(0x80)));
    input0_val =  bitcast<vec4<i32>>((input0_val_u >> vec4<u32>(1)) & vec4<u32>(0x3F));

    let mask = (input0_val & vec4<i32>(0x20)) != vec4<i32>(0);
    input0_val = select(input0_val, input0_val - 0x40, mask);

    *input0 = input0_val;
    *input1 = input1_val;
}

fn uncontract_color(input: vec4<i32>) -> vec4<i32> {
	let mask = vec4<bool>(true, true, false, false);
	let bc0 = (input + input.b) >> vec4<u32>(1);
	return select(input, bc0, mask);
}

fn rgba_delta_unpack(
	input0: vec4<i32>,
	input1: vec4<i32>,
	output0: ptr<function, vec4<i32>>,
	output1: ptr<function, vec4<i32>>
) {
	var i0 = input0;
	var i1 = input1;

	//apply bit transfer
	bit_transfer_signed(&i1, &i0);

	//apply blue contraction if needed
	let rgb_sum = i1.r + i1.g + i1.b;
	i1 = i1 + i0;
	if(rgb_sum < 0) {
		i0 = uncontract_color(i0);
		i1 = uncontract_color(i1);

		let temp = i0;
		i0 = i1;
		i1 = temp;
	}

	*output0 = clamp(i0, vec4<i32>(0), vec4<i32>(255));
	*output1 = clamp(i1, vec4<i32>(0), vec4<i32>(255));
}

fn rgba_unpack(
	input0: vec4<i32>,
	input1: vec4<i32>,
	output0: ptr<function, vec4<i32>>,
	output1: ptr<function, vec4<i32>>
) {
	var i0 = input0;
	var i1 = input1;

	//Apply blue contraction if needed
	if((i0.r + i0.g + i0.b) > (i1.r + i1.g + i1.b)) {
		i0 = uncontract_color(i0);
		i1 = uncontract_color(i1);

		let temp = i0;
		i0 = i1;
		i1 = temp;
	}

	*output0 = i0;
	*output1 = i1;
}

fn try_quantize_rgb_delta_blue_contract(
    color0: vec4<f32>,
    color1: vec4<f32>,
    color0_out: ptr<function, vec4<i32>>,
    color1_out: ptr<function, vec4<i32>>,
    quant_level: u32
) -> bool {

    //Swap endpoints at the start
    var c0 = color1;
    var c1 = color0;

    // Apply inverse blue contraction
    c0 = c0 + c0 - c0.bbba;
    c1 = c1 + c1 - c1.bbba;

    //check for out of range
    let c0_out = (c0 < vec4<f32>(0.0f)) | (c0 > vec4<f32>(255.0f));
    let c1_out = (c1 < vec4<f32>(0.0f)) | (c1 > vec4<f32>(255.0f));
    if(any(c0_out | c1_out)) {
     return false; // Out of range, cannot quantize
	}

    //Transform color0 to unorm9
    var c0a = vec4<i32>(round(c0));
    c0.a = 0.0; // copied from C++ code, unclear why we do this, since it is not used later
    c0a = c0a << vec4<u32>(1);

    // Mask off the top bit
    var c0b = c0a & vec4<i32>(0xFF);

    //quantize and then unquantize
    let c0be = quant_color3_int(quant_level, c0b);
    c0b = c0be | (c0a & vec4<i32>(0x100));

    // Get second value
    var c1d = vec4<i32>(round(c1));
    c1d = c1d << vec4<u32>(1);

    //take differences
    c1d = c1d - c0b;
    c1d.a = 0;

    //Check if diffrence is to large to encode
    if(any((c1d > vec4<i32>(63)) | (c1d < vec4<i32>(-64)))) {
        return false; // Difference too large to encode
    }

    //Insert top bit of the base into offset
    c1d = c1d & vec4<i32>(0x7F);
    c1d = c1d | ((c0b & vec4<i32>(0x100)) >> vec4<u32>(1));

    //Quantize and unquantize
    //If either top two bits flip, we cannot encode, since top bit of base ot sign of offset is corrupted
    let c1de = quant_color3_int(quant_level, c1d);

    var color_flips = (c1d ^ c1de) & vec4<i32>(0xC0);
    color_flips.a = 0; // Ignore alpha channel for this check
    if (any(color_flips != vec4<i32>(0))) {
		return false; // Color flip detected, cannot encode
	}

    // If sum of offsets does not trigger blue contraction, encoding fails
    var ep0 = c0be;
    var ep1 = c1de;
    bit_transfer_signed(&ep1, &ep0);
    if((ep1.r + ep1.g + ep1.b) >= 0) {
        return false;
    }

    // check if offsets produce legitimate sum
    ep0 = ep0 + ep1;
    if (any((ep0 < vec4<i32>(0)) | (ep0 > vec4<i32>(0xFF)))) {
		return false;
	}

    // Store the quantized endpoints
	*color0_out = c0be;
	*color1_out = c1de;

	return true; // Successfully quantized
}

fn try_quantize_rgb_delta(
    color0: vec4<f32>,
    color1: vec4<f32>,
    color0_out: ptr<function, vec4<i32>>,
    color1_out: ptr<function, vec4<i32>>,
    quant_level: u32
) -> bool {
	
	// Transform color0 to unorm9
	var c0a = vec4<i32>(round(color0));
	c0a = c0a << vec4<u32>(1);

	//Mask off the top bit
	var c0b = c0a & vec4<i32>(0xFF);

	// Quantize and then unquantize
	let c0be = quant_color3_int(quant_level, c0b);
	c0b = c0be | (c0a & vec4<i32>(0x100));

	// Get second value
	var c1d = vec4<i32>(round(color1));
	c1d = c1d << vec4<u32>(1);

	// Take differences
	c1d = c1d - c0b;
	c1d.a = 0;

	// Check if difference is too large to encode
	if (any((c1d > vec4<i32>(63)) | (c1d < vec4<i32>(-64)))) {
		return false; // Difference too large to encode
	}

	// Insert top bit of the base into offset
	c1d = c1d & vec4<i32>(0x7F);
	c1d = c1d | ((c0b & vec4<i32>(0x100)) >> vec4<u32>(1));

	// Quantize and unquantize
	let c1de = quant_color3_int(quant_level, c1d);

	var color_flips = (c1d ^ c1de) & vec4<i32>(0xC0);
    color_flips.a = 0; // Ignore alpha channel for this check
    if (any(color_flips != vec4<i32>(0))) {
		return false; // Color flip detected, cannot encode
	}

	// If the sum of offsets triggers blue contraction, encoding fails
	var ep0 = c0be;
	var ep1 = c1de;
	bit_transfer_signed(&ep1, &ep0);
	if ((ep1.r + ep1.g + ep1.b) < 0) {
		return false;
	}

	// Check if offsets produce legitimate sum
	ep0 = ep0 + ep1;
	if (any((ep0 < vec4<i32>(0)) | (ep0 > vec4<i32>(0xFF)))) {
		return false;
	}

	// Store the quantized endpoints
	*color0_out = c0be;
	*color1_out = c1de;

	return true; // Successfully quantized
}

fn try_quantize_rgb_blue_contract(
    color0: vec4<f32>,
    color1: vec4<f32>,
    color0_out: ptr<function, vec4<i32>>,
    color1_out: ptr<function, vec4<i32>>,
    quant_level: u32
) -> bool {

	var c0 = color0;
	var c1 = color1;
	
	// Apply inverse blue contraction
	c0 = c0 + c0 - c0.bbba;
	c1 = c1 + c1 - c1.bbba;

	// Check for out of range
	let c0_out = (c0 < vec4<f32>(0.0f)) | (c0 > vec4<f32>(255.0f));
	let c1_out = (c1 < vec4<f32>(0.0f)) | (c1 > vec4<f32>(255.0f));
	if (any(c0_out | c1_out)) {
		return false; // Out of range, cannot quantize
	}

	// Quantize the inverse bulue contracted colors
	let c0i = quant_color3_flt(quant_level, vec4<i32>(round(c0)), c0);
	let c1i = quant_color3_flt(quant_level, vec4<i32>(round(c1)), c1);

	//If color 1 is not greater than color 0, blue contraction can't be used
	if((c1i.r + c1i.g + c1i.b) <= (c0i.r + c0i.g + c0i.b)) {
		return false;
	}

	//swap output endpoints
	*color0_out = c1i;
	*color1_out = c0i;

	return true; // Successfully quantized
}

//This encoding cannot fail but must produce a sencible result
//color 0 cannot be larger than color 1. If it is, color0 is reduced and color1 increased
//until the condition is met
fn quantize_rgb(
    color0: vec4<f32>,
    color1: vec4<f32>,
    color0_out: ptr<function, vec4<i32>>,
    color1_out: ptr<function, vec4<i32>>,
    quant_level: u32
) {
	var c0 = color0;
	var c1 = color1;
	var c0i: vec4<i32>;
	var c1i: vec4<i32>;

	let nudge = vec4<f32>(0.2f);

	loop {
		let c0q = max(vec4<i32>(round(c0)), vec4<i32>(0));
		c0i = quant_color3_flt(quant_level, c0q, c0);
		c0 = c0 - nudge;

		let c1q = min(vec4<i32>(round(c1)), vec4<i32>(255));
		c1i = quant_color3_flt(quant_level, c1q, c1);
		c1 = c1 + nudge;

		if ((c0i.r + c0i.g + c0i.b) <= (c1i.r + c1i.g + c1i.b)) {
            break;
        }
	}

	*color0_out = c0i;
	*color1_out = c1i;

}

fn try_quantize_alpha_delta(
    color0: vec4<f32>,
    color1: vec4<f32>,
    color0_out: ptr<function, vec4<i32>>,
    color1_out: ptr<function, vec4<i32>>,
    quant_level: u32
) -> bool {

	let a0 = color0.a;
	let a1 = color1.a;

	var a0a = i32(round(a0));
	a0a = a0a << 1;
	var a0b = a0a & 0xFF;
	let a0be = i32(quant_color_int(quant_level, a0b));
	a0b = a0be | (a0a & 0x100);

	var a1d = i32(round(a1));
	a1d = a1d << 1;
	a1d = a1d - a0b;

	if (a1d > 63 || a1d < -64) {
		return false;
	}

	a1d = a1d & 0x7F;
	a1d = a1d | ((a0b & 0x100) >> 1);

	let a1de = i32(quant_color_int(quant_level, a1d));
	var a1du = a1de;
	if (((a1d ^ a1du) & 0xC0) != 0) {
		return false; // Color flip detected, cannot encode
	}

	a1du = a1du & 0x7F;
	if((a1du & 0x40) != 0) {
		a1du = a1du - 0x80;
	}

	a1du = a1du + a0b;
	if (a1du < 0 || a1du > 0x1FF) {
		return false;
	}

	// Store the quantized alpha
	(*color0_out).a = a0be;
	(*color1_out).a = a1de;

	return true; // Successfully quantized
}

fn try_quantize_rgba_delta_blue_contract(
    color0: vec4<f32>,
    color1: vec4<f32>,
    color0_out: ptr<function, vec4<i32>>,
    color1_out: ptr<function, vec4<i32>>,
    quant_level: u32
) -> bool {
	//swap color0 and color1 ordering for alpha to match RGB blue-contract
	return try_quantize_rgb_delta_blue_contract(color0, color1, color0_out, color1_out, quant_level) &&
		   try_quantize_alpha_delta(color1, color0, color0_out, color1_out, quant_level);
}

fn try_quantize_rgba_delta(
    color0: vec4<f32>,
    color1: vec4<f32>,
    color0_out: ptr<function, vec4<i32>>,
    color1_out: ptr<function, vec4<i32>>,
    quant_level: u32
) -> bool {
	return try_quantize_rgb_delta(color0, color1, color0_out, color1_out, quant_level) &&
		   try_quantize_alpha_delta(color0, color1, color0_out, color1_out, quant_level);
}

fn try_quantize_rgba_blue_contract(
    color0: vec4<f32>,
    color1: vec4<f32>,
    color0_out: ptr<function, vec4<i32>>,
    color1_out: ptr<function, vec4<i32>>,
    quant_level: u32
) -> bool {
	if(try_quantize_rgb_blue_contract(color0, color1, color0_out, color1_out, quant_level)) {
		let a0 = color0.a;
		let a1 = color1.a;

		(*color0_out).a = i32(quant_color_flt(quant_level, i32(round(a1)), a1));
		(*color1_out).a = i32(quant_color_flt(quant_level, i32(round(a0)), a0));

		return true; // Successfully quantized
	}

	return false;
}

fn quantize_rgba(
    color0: vec4<f32>,
    color1: vec4<f32>,
    color0_out: ptr<function, vec4<i32>>,
    color1_out: ptr<function, vec4<i32>>,
    quant_level: u32
) {
	quantize_rgb(color0, color1, color0_out, color1_out, quant_level);

	let a0 = color0.a;
	let a1 = color1.a;

	(*color0_out).a = i32(quant_color_flt(quant_level, i32(round(a0)), a0));
	(*color1_out).a = i32(quant_color_flt(quant_level, i32(round(a1)), a1));
}

fn quantize_rgbs(
	color: vec4<f32>,
	output: ptr<function, array<u32, 8>>,
	quant_level: u32
) {
	let scale = 1.0f / 257.0f;

	let r = clamp((color.r * scale), 0.0, 255.0);
	let g = clamp((color.g * scale), 0.0, 255.0);
	let b = clamp((color.b * scale), 0.0, 255.0);

	let ri = quant_color_flt(quant_level, i32(round(r)), r);
	let gi = quant_color_flt(quant_level, i32(round(g)), g);
	let bi = quant_color_flt(quant_level, i32(round(b)), b);

	let oldcolorsum = (color.r + color.g + color.b) * scale;
	let newcolorsum = f32(ri + gi + bi);

	let scalea = clamp((color.a * (oldcolorsum + 1e-10) / (newcolorsum + 1e-10)), 0.0, 1.0);
	var scale_idx = i32(round(scalea * 256.0));
	scale_idx = clamp(scale_idx, 0, 255);

	(*output)[0] = ri;
	(*output)[1] = gi;
	(*output)[2] = bi;
	(*output)[3] = quant_color_int(quant_level, scale_idx);
}

fn quantize_rgbs_alpha(
    color0: vec4<f32>,
    color1: vec4<f32>,
	color: vec4<f32>,
    output: ptr<function, array<u32, 8>>,
    quant_level: u32
) {
	let a0 = color0.a;
	let a1 = color1.a;

	(*output)[4] = quant_color_flt(quant_level, i32(round(a0)), a0);
	(*output)[5] = quant_color_flt(quant_level, i32(round(a1)), a1);

	quantize_rgbs(color, output, quant_level);
}

fn quantize_luminance(
	color0: vec4<f32>,
    color1: vec4<f32>,
	output: ptr<function, array<u32, 8>>,
    quant_level: u32
) {
	var lum0 = (color0.r + color0.g + color0.b) / 3.0;
	var lum1 = (color1.r + color1.g + color1.b) / 3.0;

	if(lum0 > lum1) {
		let avg = (lum0 + lum1) * 0.5;
		lum0 = avg;
		lum1 = avg;
	}

	(*output)[0] = quant_color_flt(quant_level, i32(round(lum0)), lum0);
	(*output)[1] = quant_color_flt(quant_level, i32(round(lum1)), lum1);
}

fn try_quantize_luminance_alpha_delta(
	color0: vec4<f32>,
	color1: vec4<f32>,
	output: ptr<function, array<u32, 8>>,
	quant_level: u32
) -> bool {
	
	let l0 = (color0.r + color0.g + color0.b) / 3.0;
	let l1 = (color1.r + color1.g + color1.b) / 3.0;

	let a0 = color0.a;
	let a1 = color1.a;

	var l0a = i32(round(l0));
	var a0a = i32(round(a0));
	l0a = l0a << 1;
	a0a = a0a << 1;

	var l0b = l0a & 0xFF;
	var a0b = a0a & 0xFF;
	let l0be = quant_color_int(quant_level, l0b);
	let a0be = quant_color_int(quant_level, a0b);
	l0b = i32(l0be) | (l0a & 0x100);
	a0b = i32(a0be) | (a0a & 0x100);

	var l1d = i32(round(l1));
	var a1d = i32(round(a1));
	l1d = l1d << 1;
	a1d = a1d << 1;
	l1d = l1d - l0b;
	a1d = a1d - a0b;

	if (l1d > 63 || l1d < -64 || a1d > 63 || a1d < -64) {
		return false; // Difference too large to encode
	}

	l1d = l1d & 0x7F;
	a1d = a1d & 0x7F;
	l1d = l1d | ((l0b & 0x100) >> 1);
	a1d = a1d | ((a0b & 0x100) >> 1);

	let l1de = quant_color_int(quant_level, l1d);
	let a1de = quant_color_int(quant_level, a1d);
	var l1du = i32(l1de);
	var a1du = i32(a1de);

	if(((l1d ^ l1du) & 0xC0) != 0) {
		return false;
	}

	if(((a1d ^ a1du) & 0xC0) != 0) {
		return false;
	}

	l1du = l1du & 0x7F;
	a1du = a1du & 0x7F;

	if((l1du & 0x40) != 0) {
		l1du = l1du - 0x80;
	}

	if((a1du & 0x40) != 0) {
		a1du = a1du - 0x80;
	}

	l1du = l1du + l0b;
	a1du = a1du + a0b;

	if (l1du < 0 || l1du > 0x1FF || a1du < 0 || a1du > 0x1FF) {
		return false;
	}

	// Store the quantized luminance and alpha
	(*output)[0] = l0be;
	(*output)[1] = l1de;
	(*output)[2] = a0be;
	(*output)[3] = a1de;

	return true; // Successfully quantized
}

fn quantize_luminance_alpha(
	color0: vec4<f32>,
	color1: vec4<f32>,
	output: ptr<function, array<u32, 8>>,
	quant_level: u32
) {
	let lum0 = (color0.r + color0.g + color0.b) / 3.0;
	let lum1 = (color1.r + color1.g + color1.b) / 3.0;

	let a0 = color0.a;
	let a1 = color1.a;

	(*output)[0] = quant_color_flt(quant_level, i32(round(lum0)), lum0);
	(*output)[1] = quant_color_flt(quant_level, i32(round(lum1)), lum1);
	(*output)[2] = quant_color_flt(quant_level, i32(round(a0)), a0);
	(*output)[3] = quant_color_flt(quant_level, i32(round(a1)), a1);
}


//------------------------------------------------------------------------------------------------

// This is the main helper function, a direct translation of the C++ `pack_color_endpoints`
fn pack_color_endpoints_helper(
    color0: vec4<f32>,
    color1: vec4<f32>,
    rgbs_color: vec4<f32>,
    format_spec: u32,
    quant_level: u32
) -> PackedPartitionResult {

    // Clamp and scale to the 0-255 range for quantization
    let color0_ldr = clamp(color0, vec4<f32>(0.0), vec4<f32>(65535.0)) / 257.0;
    let color1_ldr = clamp(color1, vec4<f32>(0.0), vec4<f32>(65535.0)) / 257.0;

    var best_error = ERROR_CALC_DEFAULT;
	var packed_output = array<u32, 8>(0,0,0,0,0,0,0,0);
	var best_format = FMT_LUMINANCE; // Default format

	var color0_out = vec4<i32>(0);
	var color1_out = vec4<i32>(0);
	var color0_out2 = vec4<i32>(0);
	var color1_out2 = vec4<i32>(0);

    switch (format_spec) {
        case FMT_RGB: {
			if(quant_level <= 18) { //QUANT_160 = 18

				if(try_quantize_rgb_delta_blue_contract(color0_ldr, color1_ldr, &color0_out, &color1_out, quant_level)) {
					var color0_unpacked = vec4<i32>(0);
					var color1_unpacked = vec4<i32>(0);
					rgba_delta_unpack(color0_out, color1_out, &color0_unpacked, &color1_unpacked);

					best_format = FMT_RGB_DELTA;
					best_error = get_rgba_encoding_error(color0_ldr, color1_ldr, color0_unpacked, color1_unpacked);
				}

				if(try_quantize_rgb_delta(color0_ldr, color1_ldr, &color0_out2, &color1_out2, quant_level)) {
					var color0_unpacked = vec4<i32>(0);
					var color1_unpacked = vec4<i32>(0);
					rgba_delta_unpack(color0_out2, color1_out2, &color0_unpacked, &color1_unpacked);

					let error = get_rgba_encoding_error(color0_ldr, color1_ldr, color0_unpacked, color1_unpacked);
					if (error < best_error) {
						best_error = error;
						best_format = FMT_RGB_DELTA;
						color0_out = color0_out2;
						color1_out = color1_out2;
					}
				}
			}

			if(quant_level < 20) { //QUANT_256 = 20
				if(try_quantize_rgb_blue_contract(color0_ldr, color1_ldr, &color0_out2, &color1_out2, quant_level)) {
					var color0_unpacked = vec4<i32>(0);
					var color1_unpacked = vec4<i32>(0);
					rgba_unpack(color0_out2, color1_out2, &color0_unpacked, &color1_unpacked);

					let error = get_rgba_encoding_error(color0_ldr, color1_ldr, color0_unpacked, color1_unpacked);
					if (error < best_error) {
						best_error = error;
						best_format = FMT_RGB;
						color0_out = color0_out2;
						color1_out = color1_out2;
					}
				}
			}

			{
				quantize_rgb(color0_ldr, color1_ldr, &color0_out2, &color1_out2, quant_level);

				var color0_unpacked = vec4<i32>(0);
				var color1_unpacked = vec4<i32>(0);
				rgba_unpack(color0_out2, color1_out2, &color0_unpacked, &color1_unpacked);

				let error = get_rgba_encoding_error(color0_ldr, color1_ldr, color0_unpacked, color1_unpacked);
				if (error < best_error) {
					best_error = error;
					best_format = FMT_RGB;
					color0_out = color0_out2;
					color1_out = color1_out2;
				}
			}

			packed_output[0] = u32(color0_out.r);
			packed_output[1] = u32(color1_out.r);
			packed_output[2] = u32(color0_out.g);
			packed_output[3] = u32(color1_out.g);
			packed_output[4] = u32(color0_out.b);
			packed_output[5] = u32(color1_out.b);

			break;
        }
        case FMT_RGBA: {
            if(quant_level <= 18) { //QUANT_160 = 18
				if(try_quantize_rgba_delta_blue_contract(color0_ldr, color1_ldr, &color0_out, &color1_out, quant_level)) {
					var color0_unpacked = vec4<i32>(0);
					var color1_unpacked = vec4<i32>(0);
					rgba_delta_unpack(color0_out, color1_out, &color0_unpacked, &color1_unpacked);

					best_format = FMT_RGBA_DELTA;
					best_error = get_rgba_encoding_error(color0_ldr, color1_ldr, color0_unpacked, color1_unpacked);
				}

				if(try_quantize_rgba_delta(color0_ldr, color1_ldr, &color0_out2, &color1_out2, quant_level)) {
					var color0_unpacked = vec4<i32>(0);
					var color1_unpacked = vec4<i32>(0);
					rgba_delta_unpack(color0_out2, color1_out2, &color0_unpacked, &color1_unpacked);

					let error = get_rgba_encoding_error(color0_ldr, color1_ldr, color0_unpacked, color1_unpacked);
					if (error < best_error) {
						best_error = error;
						best_format = FMT_RGBA_DELTA;
						color0_out = color0_out2;
						color1_out = color1_out2;
					}
				}
			}

			if(quant_level < 20) { //QUANT_256 = 20
				if(try_quantize_rgba_blue_contract(color0_ldr, color1_ldr, &color0_out2, &color1_out2, quant_level)) {
					var color0_unpacked = vec4<i32>(0);
					var color1_unpacked = vec4<i32>(0);
					rgba_unpack(color0_out2, color1_out2, &color0_unpacked, &color1_unpacked);

					let error = get_rgba_encoding_error(color0_ldr, color1_ldr, color0_unpacked, color1_unpacked);
					if (error < best_error) {
						best_error = error;
						best_format = FMT_RGBA;
						color0_out = color0_out2;
						color1_out = color1_out2;
					}
				}
			}

			{
				quantize_rgba(color0_ldr, color1_ldr, &color0_out2, &color1_out2, quant_level);

				var color0_unpacked = vec4<i32>(0);
				var color1_unpacked = vec4<i32>(0);
				rgba_unpack(color0_out2, color1_out2, &color0_unpacked, &color1_unpacked);

				let error = get_rgba_encoding_error(color0_ldr, color1_ldr, color0_unpacked, color1_unpacked);
				if (error < best_error) {
					best_error = error;
					best_format = FMT_RGBA;
					color0_out = color0_out2;
					color1_out = color1_out2;
				}
			}

			packed_output[0] = u32(color0_out.r);
			packed_output[1] = u32(color1_out.r);
			packed_output[2] = u32(color0_out.g);
			packed_output[3] = u32(color1_out.g);
			packed_output[4] = u32(color0_out.b);
			packed_output[5] = u32(color1_out.b);
			packed_output[6] = u32(color0_out.a);
			packed_output[7] = u32(color1_out.a);

			break;
        }
        case FMT_RGB_SCALE: {
			quantize_rgbs(rgbs_color, &packed_output, quant_level);
			best_format = FMT_RGB_SCALE;
			break;
		}
		case FMT_RGB_SCALE_ALPHA: {
			quantize_rgbs_alpha(color0_ldr, color1_ldr, rgbs_color, &packed_output, quant_level);
			best_format = FMT_RGB_SCALE_ALPHA;
			break;
		}
		case FMT_LUMINANCE: {
			quantize_luminance(color0_ldr, color1_ldr, &packed_output, quant_level);
			best_format = FMT_LUMINANCE;
			break;
		}
		case FMT_LUMINANCE_ALPHA: {
			if(quant_level <= 18) { //QUANT_160 = 18
				if(try_quantize_luminance_alpha_delta(color0_ldr, color1_ldr, &packed_output, quant_level)) {
					best_format = FMT_LUMINANCE_ALPHA_DELTA;
					break;
				}
			}
			quantize_luminance_alpha(color0_ldr, color1_ldr, &packed_output, quant_level);
			best_format = FMT_LUMINANCE_ALPHA;
			break;
		}
        default: {
            // Default or unsupported format
            best_format = FMT_LUMINANCE;
            quantize_luminance(color0_ldr, color1_ldr, &packed_output, quant_level);
        }
    }

	var result: PackedPartitionResult;
	result.values = packed_output;
    result.format = best_format;

    return result;
}

//------------------------------------------------------------------------------------------------

@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {

    let block_idx = global_id.x;
    let candidate_idx = block_idx * uniforms.tune_candidate_limit + global_id.y;

    let candidate = final_candidates[candidate_idx];
    let partition_count = uniforms.partition_count;

    // 1. First Pass Pack (Using normal quant_level)
    var all_same = (candidate.quant_level != candidate.quant_level_mod);
	var color_formats_normal: vec4<u32>;
	var color_values_normal: array<u32, 32>;

    for (var p = 0u; p < partition_count; p = p + 1u) {
        let rgbs_vector = candidate_rgbs_vectors[candidate_idx * BLOCK_MAX_PARTITIONS + p];
        
        let result = pack_color_endpoints_helper(
            candidate.candidate_partitions[p].endpoint0,
            candidate.candidate_partitions[p].endpoint1,
            rgbs_vector,
            candidate.formats[p],
            candidate.quant_level
        );

        color_formats_normal[p] = result.format;

		for (var i = 0u; i < 8u; i = i + 1u) {
			color_values_normal[p * 8 + i] = result.values[i];
		}
        
        if (p > 0u) {
            all_same = all_same && (result.format == color_formats_normal[0]);
        }
    }

    // 2. Second Pass Pack (Using modified quant_level, if applicable)
    var formats_matched = false;
    if (partition_count >= 2u && all_same) {
        var color_formats_mod: vec4<u32>;
        var all_same_mod = true;
		var color_values_mod: array<u32, 32>;

        for (var p = 0u; p < partition_count; p = p + 1u) {
            let rgbs_vector = candidate_rgbs_vectors[candidate_idx * BLOCK_MAX_PARTITIONS + p];
            
            let result = pack_color_endpoints_helper(
                candidate.candidate_partitions[p].endpoint0,
                candidate.candidate_partitions[p].endpoint1,
                rgbs_vector,
                candidate.formats[p],
                candidate.quant_level_mod
            );

            color_formats_mod[p] = result.format;
            
			for (var i = 0u; i < 8u; i = i + 1u) {
				color_values_mod[p * 8 + i] = result.values[i];
			}
            
            if (p > 0u && (result.format != color_formats_mod[0])) {
                all_same_mod = false;
                break;
            }
        }

        if (all_same_mod) {
            formats_matched = true;
            color_formats_normal = color_formats_mod;
            color_values_normal = color_values_mod;
        }
    }

    // 3. Final Store
	let out_ptr = &final_candidates[candidate_idx];
	(*out_ptr).color_formats_matched = select(0u, 1u, formats_matched);
	(*out_ptr).final_quant_mode = select(candidate.quant_level, candidate.quant_level_mod, formats_matched);
	(*out_ptr).final_formats = color_formats_normal;
	(*out_ptr).packed_color_values = color_values_normal;

}const BLOCK_MAX_PARTITIONS: u32 = 4u;
const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;

const TUNE_MAX_TRIAL_CANDIDATES = 8u;

//ASTC endpoint formats
const FMT_LUMINANCE = 0u;
const FMT_LUMINANCE_DELTA = 1u;
const FMT_HDR_LUMINANCE_LARGE_RANGE = 2u;
const FMT_HDR_LUMINANCE_SMALL_RANGE = 3u;
const FMT_LUMINANCE_ALPHA = 4u;
const FMT_LUMINANCE_ALPHA_DELTA = 5u;
const FMT_RGB_SCALE = 6u;
const FMT_HDR_RGB_SCALE = 7u;
const FMT_RGB = 8u;
const FMT_RGB_DELTA = 9u;
const FMT_RGB_SCALE_ALPHA = 10u;
const FMT_HDR_RGB = 11u;
const FMT_RGBA = 12u;
const FMT_RGBA_DELTA = 13u;
const FMT_HDR_RGB_LDR_ALPHA = 14u;
const FMT_HDR_RGBA = 15u;



struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};


struct FinalCandidate {
    block_mode_index: u32,
    block_mode_trial_index: u32,
    total_error: f32,
    quant_level: u32, // The original quant level
    quant_level_mod: u32,

    _padding1: u32,

	color_formats_matched: u32,
    final_quant_mode: u32, // The quant mode after checking the mod version

    formats: vec4<u32>,
    quantized_weights: array<u32, BLOCK_MAX_WEIGHTS>,
    candidate_partitions: array<IdealEndpointsAndWeightsPartition, 4>,

	final_formats: vec4<u32>, //Formats can change after quantization
    packed_color_values: array<u32, 32>, //8 integers per partition
};

struct UnpackedEndpoints {
    endpoint0: array<vec4<i32>, 4>,
    endpoint1: array<vec4<i32>, 4>,
}

//--------------------------------------------------------------------------------------------------------


@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> final_candidates: array<FinalCandidate>;

@group(0) @binding(2) var<storage, read_write> unpacked_endpoints: array<UnpackedEndpoints>;

//--------------------------------------------------------------------------------------------------------

fn uncontract_color(input: vec4<i32>) -> vec4<i32> {
	let mask = vec4<bool>(true, true, false, false);
	let bc0 = (input + input.b) >> vec4<u32>(1);
	return select(input, bc0, mask);
}

fn bit_transfer_signed(input0: ptr<function, vec4<i32>>, input1: ptr<function, vec4<i32>>) {
    var input0_val = *input0;
    var input1_val = *input1;

    //preform shifts on unsigned interegers to guarantee logical shifts
    let input0_val_u = bitcast<vec4<u32>>(input0_val);
    let input1_val_u = bitcast<vec4<u32>>(input1_val);

    input1_val =  bitcast<vec4<i32>>((input1_val_u >> vec4<u32>(1)) | (input0_val_u & vec4<u32>(0x80)));
    input0_val =  bitcast<vec4<i32>>((input0_val_u >> vec4<u32>(1)) & vec4<u32>(0x3F));

    let mask = (input0_val & vec4<i32>(0x20)) != vec4<i32>(0);
    input0_val = select(input0_val, input0_val - 0x40, mask);

    *input0 = input0_val;
    *input1 = input1_val;
}

fn luminance_unpack (
    input: array<u32, 8>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    let lum0 = i32(input[0]);
    let lum1 = i32(input[1]);
    (*output0) = vec4<i32>(lum0, lum0, lum0, 255);
	(*output1) = vec4<i32>(lum1, lum1, lum1, 255);
}

fn luminance_delta_unpack (
    input: array<u32, 8>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    let v0 = i32(input[0]);
    let v1 = i32(input[1]);
    
    let lum0 = (v0 >> 2) | (v1 & 0xC0);
    var lum1 = lum0 + (v1 & 0x3F);

    lum1 = min(lum1, 255);

    (*output0) = vec4<i32>(lum0, lum0, lum0, 255);
	(*output1) = vec4<i32>(lum1, lum1, lum1, 255);
}

fn luminance_alpha_unpack (
    input: array<u32, 8>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    let lum0 = i32(input[0]);
    let lum1 = i32(input[1]);
    let alpha0 = i32(input[2]);
    let alpha1 = i32(input[3]);

	(*output0) = vec4<i32>(lum0, lum0, lum0, alpha0);
    (*output1) = vec4<i32>(lum1, lum1, lum1, alpha1);
}

fn luminance_alpha_delta_unpack (
    input: array<u32, 8>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    var lum0 = i32(input[0]);
    var lum1 = i32(input[1]);
    var alpha0 = i32(input[2]);
    var alpha1 = i32(input[3]);

    lum0 = lum0 | ((lum1 & 0x80) << 1);
    alpha0 = alpha0 | ((alpha1 & 0x80) << 1);
    lum1 = lum1 & 0x7F;
    alpha1 = alpha1 & 0x7F;

    if((lum1 & 0x40) != 0) {
        lum1 = lum1 - 0x80;
    }

    if((alpha1 & 0x40) != 0) {
		alpha1 = alpha1 - 0x80;
    }

    lum0 = lum0 >> 1;
    lum1 = lum1 >> 1;
    alpha0 = alpha0 >> 1;
    alpha1 = alpha1 >> 1;

    lum1 = lum0 + lum1;
    alpha1 = alpha0 + alpha1;

    lum1 = clamp(lum1, 0, 255);
    alpha1 = clamp(alpha1, 0, 255);

	(*output0) = vec4<i32>(lum0, lum0, lum0, alpha0);
    (*output1) = vec4<i32>(lum1, lum1, lum1, alpha1);
}

fn rgb_scale_unpack (
    input: array<u32, 8>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    var input0 = vec4<i32>(i32(input[0]), i32(input[1]), i32(input[2]), 255);
    let scale = i32(input[3]);

    (*output1) = input0;

    input0 = (input0 * scale) >> vec4<u32>(8);
    input0.a = 255;
    
    (*output0) = input0;
}

fn rgb_scale_alpha_unpack (
    input: array<u32, 8>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    var input0 = vec4<i32>(i32(input[0]), i32(input[1]), i32(input[2]), i32(input[4]));
    let scale = i32(input[3]);
    let alpha0 = i32(input[4]);
    let alpha1 = i32(input[5]);

    (*output1) = vec4<i32>(input0.r, input0.g, input0.b, alpha1);

    input0 = (input0 * scale) >> vec4<u32>(8);
	input0.a = alpha0;

	(*output0) = input0;
}

fn rgba_unpack (
    input0: vec4<i32>,
    input1: vec4<i32>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    var i0 = input0;
    var i1 = input1;

    //Apply blue uncontaction if needed
    if((i0.r + i0.g + i0.b) > (i1.r + i1.g + i1.b)) {
        i0 = uncontract_color(i0);
        i1 = uncontract_color(i1);

        let temp = i0;
        i0 = i1;
        i1 = temp;
    }

	(*output0) = i0;
    (*output1) = i1;
}

fn rgb_unpack (
    input0: vec4<i32>,
    input1: vec4<i32>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    rgba_unpack(input0, input1, output0, output1);
	(*output0).a = 255;
	(*output1).a = 255;
}

fn rgba_delta_unpack (
    input0: vec4<i32>,
    input1: vec4<i32>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    var i0 = input0;
    var i1 = input1;

    bit_transfer_signed(&i1, &i0);

    //Apply blue contraction in needed
    let rgb_sum = i1.r + i1.g + i1.b;
    i1 = i1 + i0;
    if(rgb_sum < 0) {
        i0 = uncontract_color(i0);
        i1 = uncontract_color(i1);

        let temp = i0;
        i0 = i1;
        i1 = temp;
    }

    (*output0) = clamp(i0, vec4<i32>(0), vec4<i32>(255));
    (*output1) = clamp(i1, vec4<i32>(0), vec4<i32>(255));
}

fn rgb_delta_unpack (
    input0: vec4<i32>,
    input1: vec4<i32>,
    output0: ptr<function, vec4<i32>>,
    output1: ptr<function, vec4<i32>>
) {
    rgba_delta_unpack(input0, input1, output0, output1);
    (*output0).a = 255;
    (*output1).a = 255;
}

//--------------------------------------------------------------------------------------------------------

@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {

    let block_idx = global_id.x;
    let candidate_idx = block_idx * uniforms.tune_candidate_limit + global_id.y;
    let partition_count = uniforms.partition_count;

    let foramts = final_candidates[candidate_idx].final_formats;
    let packed_color_values = final_candidates[candidate_idx].packed_color_values;

    // Unpack the endpoints for each partition
    for(var p = 0u; p < partition_count; p = p + 1u) {
        let format = foramts[p];

        var packed_endpoint: array<u32, 8>;
        for (var i = 0u; i < 8u; i = i + 1u) {
            packed_endpoint[i] = packed_color_values[p * 8u + i];
        }

        var output0: vec4<i32>;
        var output1: vec4<i32>;

        switch (format) {
            case FMT_LUMINANCE: {
                luminance_unpack(packed_endpoint, &output0, &output1);
                break;
            }
            case FMT_LUMINANCE_DELTA: {
                luminance_delta_unpack(packed_endpoint, &output0, &output1);
                break;
            }
            case FMT_LUMINANCE_ALPHA: {
                luminance_alpha_unpack(packed_endpoint, &output0, &output1);
                break;
            }
            case FMT_LUMINANCE_ALPHA_DELTA: {
                luminance_alpha_delta_unpack(packed_endpoint, &output0, &output1);
                break;
            }
            case FMT_RGB_SCALE: {
                rgb_scale_unpack(packed_endpoint, &output0, &output1);
                break;
            }
            case FMT_RGB_SCALE_ALPHA: {
                rgb_scale_alpha_unpack(packed_endpoint, &output0, &output1);
                break;
            }
            case FMT_RGB: {
                let input0 = vec4<i32>(i32(packed_endpoint[0]), i32(packed_endpoint[2]), i32(packed_endpoint[4]), 0);
                let input1 = vec4<i32>(i32(packed_endpoint[1]), i32(packed_endpoint[3]), i32(packed_endpoint[5]), 0);
                rgb_unpack(input0, input1, &output0, &output1);
                break;
            }
            case FMT_RGB_DELTA: {
                let input0 = vec4<i32>(i32(packed_endpoint[0]), i32(packed_endpoint[2]), i32(packed_endpoint[4]), 0);
                let input1 = vec4<i32>(i32(packed_endpoint[1]), i32(packed_endpoint[3]), i32(packed_endpoint[5]), 0);
                rgb_delta_unpack(input0, input1, &output0, &output1);
                break;
            }
            case FMT_RGBA: {
                let input0 = vec4<i32>(i32(packed_endpoint[0]), i32(packed_endpoint[2]), i32(packed_endpoint[4]), i32(packed_endpoint[6]));
                let input1 = vec4<i32>(i32(packed_endpoint[1]), i32(packed_endpoint[3]), i32(packed_endpoint[5]), i32(packed_endpoint[7]));
                rgba_unpack(input0, input1, &output0, &output1);
                break;
            }
            case FMT_RGBA_DELTA: {
                let input0 = vec4<i32>(i32(packed_endpoint[0]), i32(packed_endpoint[2]), i32(packed_endpoint[4]), i32(packed_endpoint[6]));
                let input1 = vec4<i32>(i32(packed_endpoint[1]), i32(packed_endpoint[3]), i32(packed_endpoint[5]), i32(packed_endpoint[7]));
                rgba_delta_unpack(input0, input1, &output0, &output1);
                break;
            }
            default: {
                luminance_unpack(packed_endpoint, &output0, &output1);
            }
        }

        output0 = output0 * 257;
        output1 = output1 * 257;

        //store outputs
        unpacked_endpoints[candidate_idx].endpoint0[p] = output0;
        unpacked_endpoints[candidate_idx].endpoint1[p] = output1;
    }

}
const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const BLOCK_MAX_PARTITIONS: u32 = 4u;

const TUNE_MAX_TRIAL_CANDIDATES = 8u;

//A table of previous and next weights, indexed by current value
//bits 7:0 previous value
//bits 15:8 next value
//table is flattened. Index is: quant_level * 65 + value
//table size is: 12 (QUANT_2 up to QUANT_32) * 65 (values from 0 up to 64) = 780
const ALL_PREV_NEXT_VALUES = array<u32, 780>(
    //QUANT_2
    0x4000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0x4000,
    //QUANT_3
    0x2000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0x4000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0x4020,
    //QUANT_4
    0x1500,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x2b00,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x4015,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0x402b,
    //QUANT_5
    0x1000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x2000,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0x3010,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x4020,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0x4030,
    //QUANT_6
    0x0c00,0,0,0,0,0,0,0,0,0,0,0,0x1900,0,0,0,0,0,0,0,0,0,0,0,0,
    0x270c,0,0,0,0,0,0,0,0,0,0,0,0,0,0x3419,0,0,0,0,0,0,0,0,0,0,
    0,0,0x4027,0,0,0,0,0,0,0,0,0,0,0,0x4034,
    //QUANT_8
    0x0900,0,0,0,0,0,0,0,0,0x1200,0,0,0,0,0,0,0,0,0x1b09,0,0,
    0,0,0,0,0,0,0x2512,0,0,0,0,0,0,0,0,0,0x2e1b,0,0,0,0,0,0,0,0,
    0x3725,0,0,0,0,0,0,0,0,0x402e,0,0,0,0,0,0,0,0,0x4037,
    //QUANT_10
    0x0700,0,0,0,0,0,0,0x0e00,0,0,0,0,0,0,0x1507,0,0,0,0,0,0,
    0x1c0e,0,0,0,0,0,0,0x2415,0,0,0,0,0,0,0,0x2b1c,0,0,0,0,0,
    0,0x3224,0,0,0,0,0,0,0x392b,0,0,0,0,0,0,0x4032,0,0,0,0,0,
    0,0x4039,
    //QUANT_12
    0x0500,0,0,0,0,0x0b00,0,0,0,0,0,0x1105,0,0,0,0,0,
    0x170b,0,0,0,0,0,0x1c11,0,0,0,0,0x2417,0,0,0,0,0,0,0,
    0x291c,0,0,0,0,0x2f24,0,0,0,0,0,0x3529,0,0,0,0,0,
    0x3b2f,0,0,0,0,0,0x4035,0,0,0,0,0x403b,
    //QUANT_16
    0x0400,0,0,0,0x0800,0,0,0,0x0c04,0,0,0,0x1108,0,0,0,0,
    0x150c,0,0,0,0x1911,0,0,0,0x1d15,0,0,0,0x2319,0,0,0,0,
    0,0x271d,0,0,0,0x2b23,0,0,0,0x2f27,0,0,0,0x342b,0,0,0,
    0,0x382f,0,0,0,0x3c34,0,0,0,0x4038,0,0,0,0x403c,
    //QUANT_20
    0x0300,0,0,0x0600,0,0,0x0903,0,0,0x0d06,0,0,0,
    0x1009,0,0,0x130d,0,0,0x1710,0,0,0,0x1a13,0,0,
    0x1d17,0,0,0x231a,0,0,0,0,0,0x261d,0,0,0x2923,0,0,
    0x2d26,0,0,0,0x3029,0,0,0x332d,0,0,0x3730,0,0,0,
    0x3a33,0,0,0x3d37,0,0,0x403a,0,0,0x403d,
    //QUANT_24
    0x0200,0,0x0500,0,0,0x0802,0,0,0x0b05,0,0,0x0d08,
    0,0x100b,0,0,0x130d,0,0,0x1610,0,0,0x1813,0,
    0x1b16,0,0,0x1e18,0,0,0x221b,0,0,0,0x251e,0,0,
    0x2822,0,0,0x2a25,0,0x2d28,0,0,0x302a,0,0,0x332d,
    0,0,0x3530,0,0x3833,0,0,0x3b35,0,0,0x3e38,0,0,
    0x403b,0,0x403e,
    //QUNAT_32
    0x0200,0,0x0400,0,0x0602,0,0x0804,0,0x0a06,0,
    0x0c08,0,0x0e0a,0,0x100c,0,0x120e,0,0x1410,0,
    0x1612,0,0x1814,0,0x1a16,0,0x1c18,0,0x1e1a,0,
    0x221c,0,0,0,0x241e,0,0x2622,0,0x2824,0,0x2a26,0,
    0x2c28,0,0x2e2a,0,0x302c,0,0x322e,0,0x3430,0,
    0x3632,0,0x3834,0,0x3a36,0,0x3c38,0,0x3e3a,0,
    0x403c,0,0x403e
);

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct BlockMode {
	mode_index : u32,
    decimation_mode : u32,
    quant_mode : u32,
    weight_bits : u32,
    is_dual_plane : u32,

    _padding1 : u32,
    _padding2 : u32,
    _padding3 : u32,
};

struct DecimationInfo {
    texel_count : u32,
    weight_count : u32,
    weight_x : u32,
    weight_y : u32,

    max_quant_level : u32,
    max_angular_steps : u32,
    max_quant_steps: u32,
    _padding: u32,

    texel_weight_count : array<u32, BLOCK_MAX_TEXELS>,
    texel_weights_offset : array<u32, BLOCK_MAX_TEXELS>,

    weight_texel_count : array<u32, BLOCK_MAX_WEIGHTS>,
    weight_texels_offset : array<u32, BLOCK_MAX_WEIGHTS>,
};

struct TexelToWeightMap {
	weight_index : u32,
	contribution : f32,

    _padding1 : u32,
    _padding2 : u32,
};

struct WeightToTexelMap {
    texel_index : u32,
	contribution : f32,

    _padding1 : u32,
    _padding2 : u32,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct UnpackedEndpoints {
    endpoint0: array<vec4<i32>, 4>,
    endpoint1: array<vec4<i32>, 4>,
}

struct FinalCandidate {
    block_mode_index: u32,
    block_mode_trial_index: u32,
    total_error: f32,
    quant_level: u32, // The original quant level
    quant_level_mod: u32,

    _padding1: u32,

	color_formats_matched: u32,
    final_quant_mode: u32, // The quant mode after checking the mod version

    formats: vec4<u32>,
    quantized_weights: array<u32, BLOCK_MAX_WEIGHTS>,
    candidate_partitions: array<IdealEndpointsAndWeightsPartition, 4>,

	final_formats: vec4<u32>, //Formats can change after quantization
    packed_color_values: array<u32, 32>, //8 integers per partition
};



@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> block_modes: array<BlockMode>;
@group(0) @binding(2) var<storage, read> decimation_infos: array<DecimationInfo>;
@group(0) @binding(3) var<storage, read> texel_to_weight_map: array<TexelToWeightMap>;
@group(0) @binding(4) var<storage, read> weight_to_texel_map: array<WeightToTexelMap>;
@group(0) @binding(5) var<storage, read> input_blocks: array<InputBlock>;
@group(0) @binding(6) var<storage, read> unpacked_endpoints: array<UnpackedEndpoints>;

@group(0) @binding(7) var<storage, read_write> final_candidates: array<FinalCandidate>;



var<workgroup> uq_weightsf: array<f32, BLOCK_MAX_WEIGHTS>; 

var<workgroup> part_offsets: array<vec4<f32>, 4>;
var<workgroup> part_bases: array<vec4<f32>, 4>;



@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {

    let block_idx = group_id.x;
    let candidate_idx = block_idx * uniforms.tune_candidate_limit + group_id.y;

    let bm = block_modes[final_candidates[candidate_idx].block_mode_index];
    let di = decimation_infos[bm.decimation_mode];
    let input_block = input_blocks[block_idx];
    let partition_count = uniforms.partition_count;


    //Unpack endpoints and pre-calculate offset vectors for all partitions.
    if (local_idx < partition_count) {
        let p = local_idx;
        let ep0 = unpacked_endpoints[candidate_idx].endpoint0[p];
        let ep1 = unpacked_endpoints[candidate_idx].endpoint1[p];

        let delta = ep1 - ep0;

        part_bases[p] = vec4<f32>(ep0);
        // The offset is the endpoint delta scaled by 1/64 for unquantization
        part_offsets[p] = vec4<f32>(delta) * (1.0 / 64.0);
    }
    workgroupBarrier();

    //Unquantize all weights to a shared float array (used for decimated weights)
    for (var i = local_idx; i < di.weight_count; i += WORKGROUP_SIZE) {
        uq_weightsf[i] = f32(final_candidates[candidate_idx].quantized_weights[i]);
    }

    workgroupBarrier();


    //Branch between decimated and undecimated logic
    if(di.weight_count == di.texel_count) {
        //realign weights undecimated

        for (var texel_idx = local_idx; texel_idx < di.texel_count; texel_idx += WORKGROUP_SIZE) {

            let candidate_weight_ptr = &final_candidates[candidate_idx].quantized_weights[texel_idx];
            let uqw = i32(*candidate_weight_ptr);

            // Look up the previous and next quantization steps
            let prev_next = ALL_PREV_NEXT_VALUES[bm.quant_mode * 65u + u32(uqw)];
            let uqw_down = i32(prev_next & 0xFFu);
            let uqw_up = i32((prev_next >> 8u) & 0xFFu);

            let weight_base = f32(uqw);
            let weight_down_diff = f32(uqw_down - uqw);
            let weight_up_diff = f32(uqw_up - uqw);

            let p = input_block.texel_partitions[texel_idx];
            let color_offset = part_offsets[p];
            let color_base = part_bases[p];
            
            let color = color_base + color_offset * weight_base;
            let orig_color = input_block.pixels[texel_idx];
            let error_weight = uniforms.channel_weights;

            let color_diff = color - orig_color;
            let color_diff_down = color_diff + color_offset * weight_down_diff;
            let color_diff_up = color_diff + color_offset * weight_up_diff;
            
            let error_base = dot(color_diff * color_diff, error_weight);
            let error_down = dot(color_diff_down * color_diff_down, error_weight);
            let error_up = dot(color_diff_up * color_diff_up, error_weight);

            // Check if moving the weight up or down improves the error
            if ((error_up < error_base) && (error_up < error_down) && (uqw < 64)) {
                *candidate_weight_ptr = u32(uqw_up);
            } else if ((error_down < error_base) && (uqw > 0)) {
                *candidate_weight_ptr = u32(uqw_down);
            }
        }
    }
    else {
        //realign weights decimated

        if(local_idx == 0) {
        for (var we_idx = 0u; we_idx < di.weight_count; we_idx += 1u) {

            let candidate_weight_ptr = &final_candidates[candidate_idx].quantized_weights[we_idx];
            let uqw = i32(*candidate_weight_ptr);
            
            let prev_next = ALL_PREV_NEXT_VALUES[bm.quant_mode * 65u + u32(uqw)];
            let uqw_down = f32(prev_next & 0xFFu);
            let uqw_up = f32((prev_next >> 8u) & 0xFFu);
            let uqw_base = f32(uqw);

            let uqw_diff_down = uqw_down - uqw_base;
            let uqw_diff_up = uqw_up - uqw_base;
            
            var error_basev = vec4<f32>(0.0);
            var error_downv = vec4<f32>(0.0);
            var error_upv = vec4<f32>(0.0);

            // Interpolate colors to get the diffs
            let texels_to_eval = di.weight_texel_count[we_idx];
            for (var te_idx = 0u; te_idx < texels_to_eval; te_idx = te_idx + 1u) {
                let wt_map = weight_to_texel_map[di.weight_texels_offset[we_idx] + te_idx];
                let texel_idx = wt_map.texel_index;

                // Perform bilinear infill for this texel
                var weight_base = 0.0;
                let tw_offset = di.texel_weights_offset[texel_idx];
                for (var j = 0u; j < di.texel_weight_count[texel_idx]; j = j + 1u) {
                    let tw_map = texel_to_weight_map[tw_offset + j];
                    weight_base += uq_weightsf[tw_map.weight_index] * tw_map.contribution;
                }

                var tw_base = 0.0;
                let tw_count = di.texel_weight_count[texel_idx];
                for (var k = 0u; k < tw_count; k = k + 1u) {
                    let tw_map = texel_to_weight_map[tw_offset + k];
                    if (tw_map.weight_index == we_idx) {
                        tw_base = tw_map.contribution;
                        break;
                    }
                }

                let weight_down_diff = uqw_diff_down * tw_base;
                let weight_up_diff = uqw_diff_up * tw_base;

                let p = input_block.texel_partitions[texel_idx];
                let color_offset = part_offsets[p];
                let color_base = part_bases[p];

                let color = color_base + color_offset * weight_base;
                let orig_color = input_block.pixels[texel_idx];

                let color_diff = color - orig_color;
                let color_diff_down = color_diff + color_offset * weight_down_diff;
                let color_diff_up = color_diff + color_offset * weight_up_diff;
                
                error_basev += color_diff * color_diff;
                error_downv += color_diff_down * color_diff_down;
                error_upv += color_diff_up * color_diff_up;
            }

            let error_weight = uniforms.channel_weights;
            let error_base = dot(error_basev, error_weight);
            let error_down = dot(error_downv, error_weight);
            let error_up = dot(error_upv, error_weight);

            if ((error_up < error_base) && (error_up < error_down) && (uqw < 64)) {
                *candidate_weight_ptr = u32(uqw_up);
                uq_weightsf[we_idx] = uqw_up;
            } else if ((error_down < error_base) && (uqw > 0)) {
                *candidate_weight_ptr = u32(uqw_down);
                uq_weightsf[we_idx] = uqw_down;
            }
        }
        }
    }

}
const WORKGROUP_SIZE: u32 = 64u;
const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const BLOCK_MAX_PARTITIONS: u32 = 4u;
const ERROR_CALC_DEFAULT: f32 = 1e37;



struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct BlockMode {
	mode_index : u32,
    decimation_mode : u32,
    quant_mode : u32,
    weight_bits : u32,
    is_dual_plane : u32,

    _padding1 : u32,
    _padding2 : u32,
    _padding3 : u32,
};

struct DecimationInfo {
    texel_count : u32,
    weight_count : u32,
    weight_x : u32,
    weight_y : u32,

    max_quant_level : u32,
    max_angular_steps : u32,
    max_quant_steps: u32,
    _padding: u32,

    texel_weight_count : array<u32, BLOCK_MAX_TEXELS>,
    texel_weights_offset : array<u32, BLOCK_MAX_TEXELS>,

    weight_texel_count : array<u32, BLOCK_MAX_WEIGHTS>,
    weight_texels_offset : array<u32, BLOCK_MAX_WEIGHTS>,
};

struct TexelToWeightMap {
	weight_index : u32,
	contribution : f32,

    _padding1 : u32,
    _padding2 : u32,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct FinalCandidate {
    block_mode_index: u32,
    block_mode_trial_index: u32,
    total_error: f32,
    quant_level: u32, // The original quant level
    quant_level_mod: u32,

    _padding1: u32,

	color_formats_matched: u32,
    final_quant_mode: u32, // The quant mode after checking the mod version

    formats: vec4<u32>,
    quantized_weights: array<u32, BLOCK_MAX_WEIGHTS>,
    candidate_partitions: array<IdealEndpointsAndWeightsPartition, 4>,

	final_formats: vec4<u32>, //Formats can change after quantization
    packed_color_values: array<u32, 32>, //8 integers per partition
};

struct UnpackedEndpoints {
    endpoint0: array<vec4<i32>, 4>,
    endpoint1: array<vec4<i32>, 4>,
}



@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> block_modes: array<BlockMode>;
@group(0) @binding(2) var<storage, read> decimation_infos: array<DecimationInfo>;
@group(0) @binding(3) var<storage, read> texel_to_weight_map: array<TexelToWeightMap>;
@group(0) @binding(4) var<storage, read> input_blocks: array<InputBlock>;
@group(0) @binding(5) var<storage, read> unpacked_endpoints: array<UnpackedEndpoints>;

@group(0) @binding(6) var<storage, read_write> final_candidates: array<FinalCandidate>;
@group(0) @binding(7) var<storage, read_write> top_candidates: array<FinalCandidate>;



var<workgroup> dec_weights: array<f32, BLOCK_MAX_WEIGHTS>;
var<workgroup> undec_weights: array<f32, BLOCK_MAX_TEXELS>;
var<workgroup> shared_total_error: atomic<u32>;


fn atomicAdd_f32(atomic_target: ptr<workgroup, atomic<u32>>, value_to_add: f32) {
    loop {
        let original_val_uint = atomicLoad(atomic_target);
        let original_val_float = bitcast<f32>(original_val_uint);
        let new_val_float = original_val_float + value_to_add;
        let new_val_uint = bitcast<u32>(new_val_float);
        let result = atomicCompareExchangeWeak(atomic_target, original_val_uint, new_val_uint);
        if (result.exchanged) {
            break;
        }
    }
}



@compute @workgroup_size(WORKGROUP_SIZE)
fn main(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32) {

    let block_idx = group_id.x;
    let candidate_idx = block_idx * uniforms.tune_candidate_limit + group_id.y;

    let bm = block_modes[final_candidates[candidate_idx].block_mode_index];
    let di = decimation_infos[bm.decimation_mode];
    let partition_count = uniforms.partition_count;

    let input_block = input_blocks[block_idx];

    let quantized_weights = final_candidates[candidate_idx].quantized_weights;

    // Unquantize and bilinear infill
    for (var i = local_idx; i < di.weight_count; i += WORKGROUP_SIZE) {
        let weight_int = quantized_weights[i];
        dec_weights[i] = f32(weight_int) / 64.0;
    }
    workgroupBarrier();

    for (var i = local_idx; i < di.texel_count; i += WORKGROUP_SIZE) {
        if (di.texel_count == di.weight_count) {
            // Undecimated Case: Perform a direct copy.
            undec_weights[i] = dec_weights[i];
        } else {
            // Decimated Case: Perform the bilinear infill.
            var infill_val: f32 = 0.0;
            let weight_offset = di.texel_weights_offset[i];
            for (var j = 0u; j < di.texel_weight_count[i]; j = j + 1u) {
                let mapping = texel_to_weight_map[weight_offset + j];
                infill_val += dec_weights[mapping.weight_index] * mapping.contribution;
            }
            undec_weights[i] = infill_val;
        }
    }
    workgroupBarrier();

    //init sum variable
    if (local_idx == 0u) {
        atomicStore(&shared_total_error, bitcast<u32>(0.0f));
    }
    workgroupBarrier();

    //sum error for all texels
    for (var i = local_idx; i < di.texel_count; i += WORKGROUP_SIZE) {
        let p = input_block.texel_partitions[i];
        if (p < partition_count) {

            let endpoint0 = unpacked_endpoints[candidate_idx].endpoint0[p];
            let endpoint1 = unpacked_endpoints[candidate_idx].endpoint1[p];

            let weight = undec_weights[i];

            let weight1 = vec4<i32>(i32(round(weight * 64.0)));
            let weight0 = vec4<i32>(64) - weight1;

            var color = (endpoint0 * weight0) + (endpoint1 * weight1) + vec4<i32>(32);
            color = color >> vec4<u32>(6);

            var diff = input_block.pixels[i] - vec4<f32>(color);
            diff = min(abs(diff), vec4<f32>(1e15f));
            
            let error = dot(diff * diff, uniforms.channel_weights);

            atomicAdd_f32(&shared_total_error, min(error, ERROR_CALC_DEFAULT));
        }
    }
    workgroupBarrier();

    //store result
    if(local_idx == 0u) {
        let total_error = bitcast<f32>(atomicLoad(&shared_total_error));

        final_candidates[candidate_idx].total_error = total_error;

        if(total_error < top_candidates[candidate_idx].total_error) {
            top_candidates[candidate_idx] = final_candidates[candidate_idx];
        }

    }

}const BLOCK_MAX_TEXELS: u32 = 144u;
const BLOCK_MAX_WEIGHTS: u32 = 64u;
const ERROR_CALC_DEFAULT: f32 = 1e37;

struct UniformVariables {
    xdim : u32,
    ydim : u32,

    texel_count : u32,

    decimation_mode_count : u32,
    block_mode_count : u32,

    valid_decimation_mode_count: u32,
	valid_block_mode_count: u32,

    quant_limit : u32,
    partition_count : u32,
    tune_candidate_limit : u32,

    _padding1: u32,
    _padding2: u32,

    channel_weights : vec4<f32>,

    partitioning_count_selected : vec4<u32>,
    partitioning_count_all : vec4<u32>,
};

struct InputBlock {
    pixels: array<vec4<f32>, BLOCK_MAX_TEXELS>,
    texel_partitions: array<u32, BLOCK_MAX_TEXELS>,
    partition_pixel_counts: array<u32, 4>,

    partitioning_idx: u32,
    grayscale: u32,
    constant_alpha: u32,
    padding: u32,
};

struct IdealEndpointsAndWeightsPartition {
    avg: vec4<f32>,
    dir: vec4<f32>,
    endpoint0: vec4<f32>,
    endpoint1: vec4<f32>,
};

struct FinalCandidate {
    block_mode_index: u32,
    block_mode_trial_index: u32,
    total_error: f32,
    quant_level: u32, // The original quant level
    quant_level_mod: u32,

    _padding1: u32,

	color_formats_matched: u32,
    final_quant_mode: u32, // The quant mode after checking the mod version

    formats: vec4<u32>,
    quantized_weights: array<u32, BLOCK_MAX_WEIGHTS>,
    candidate_partitions: array<IdealEndpointsAndWeightsPartition, 4>,

	final_formats: vec4<u32>, //Formats can change after quantization
    packed_color_values: array<u32, 32>, //8 integers per partition
};

struct BlockMode {
	mode_index : u32,
    decimation_mode : u32,
    quant_mode : u32,
    weight_bits : u32,
    is_dual_plane : u32,

    _padding1 : u32,
    _padding2 : u32,
    _padding3 : u32,
};

struct SymbolicBlock {
    errorval: f32,

    block_mode_index: u32,
    partition_count: u32,
    partition_index: u32,

    partition_formats_matched: u32,
    quant_mode: u32,

    _padding1: u32,
    _padding2: u32,

    partition_formats: vec4<u32>,

    packed_color_values: array<u32, 32>, //8 integers per partition

    quantized_weights: array<u32, BLOCK_MAX_WEIGHTS>,
};



@group(0) @binding(0) var<uniform> uniforms: UniformVariables;
@group(0) @binding(1) var<storage, read> inputBlocks: array<InputBlock>;
@group(0) @binding(2) var<storage, read> top_candidates: array<FinalCandidate>;
@group(0) @binding(3) var<storage, read> block_modes: array<BlockMode>;

@group(0) @binding(4) var<storage, read_write> output_symbolic_blocks: array<SymbolicBlock>;

@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    
    let block_idx = global_id.x;

    var best_error = ERROR_CALC_DEFAULT;
    var best_candidate_idx = 0u;

    for (var i = 0u; i < uniforms.tune_candidate_limit; i = i + 1u) {
        let candidate_idx = block_idx * uniforms.tune_candidate_limit + i;
        let current_error = top_candidates[candidate_idx].total_error;

        if (current_error < best_error) {
            best_error = current_error;
            best_candidate_idx = candidate_idx;
        }
    }

    let winner = top_candidates[best_candidate_idx];
    //let winner = top_candidates[block_idx + 0];
    let out_ptr = &output_symbolic_blocks[block_idx];

    (*out_ptr).errorval = best_error;
    (*out_ptr).block_mode_index = block_modes[winner.block_mode_index].mode_index;
    (*out_ptr).partition_count = uniforms.partition_count;
    (*out_ptr).partition_index = inputBlocks[block_idx].partitioning_idx;
    (*out_ptr).quant_mode = winner.final_quant_mode;
    (*out_ptr).partition_formats_matched = winner.color_formats_matched;

    (*out_ptr).partition_formats = winner.final_formats;
    (*out_ptr).packed_color_values = winner.packed_color_values;
    (*out_ptr).quantized_weights = winner.quantized_weights;
}
